\chapter{Sintaxis y Semántica}\label{chapter:semantics}
\lhead{Capítulo 3. \emph{Sintaxis y Semántica}}

El lenguaje imperativo de este trabajo se llama Chloe y representa un subconjunto del lenguaje C.
Un programa es una secuencia de una o más instrucciones (o comandos) escritos para llevar a cabo una tarea en una computadora.
\begin{comment}
Cada una de estas instrucciones representa una instrucción que la máquina ejecutará.
\end{comment}
Estas instrucciones pueden contener componentes internos llamados expresiones.
Una expresión es un termino que consta de valores, constantes, variables, operadores, etc. que puede ser evaluado en el contexto de un estado del programa para obtener un valor que puede ser luego utilizado en una instrucción.
En las secciones siguientes se procederá a describir la sintaxis y la semántica de los programas en Chloe con más detalle.


\section{Expresiones}\label{section:expressions}

\subsection{Sintaxis}\label{subsection:syntax_expressions}

En esta sección se describe la \textbf{sintaxis abstracta} de las expressiones en el lenguaje Chloe.

\begin{figure}
  \begin{lstlisting}[frame=single]
  type_synonym vname = string

  datatype exp = Const int
               | Null
               | V      vname
               | Plus  exp exp
               | Subt  exp exp
               | Minus exp
               | Div   exp exp
               | Mod   exp exp
               | Mult  exp exp
               | Less  exp exp
               | Not   exp
               | And   exp exp
               | Or    exp exp
               | Eq    exp exp
               | New   exp
               | Deref exp
               | Ref   lexp
               | Index exp exp
  and
  datatype lexp = Deref exp
                | Indexl exp exp
  \end{lstlisting}

  \caption{Chloe expressions}
  \label{fig:chloe_expressions}
\end{figure}

En la figura~\ref{fig:chloe_expressions} se encuentra el tipo de datos creado en isabelle para las expresiones, donde \verb|int| es el tipo predefinido para los enteros y \verb|vname| significa nombre de la variable.

Se definen dos nuevos tipos de datos, uno para las expresiones y otro para las expresiones del lado izquierdo.
Es importante diferenciar entre estos dos tipos en el caso en que se trabaja con expresiones que contienen apuntadores.
Por ejemplo, suponiendo que se tienen las siguientes instrucciones en C:

\begin{lstlisting}[mathescape=true, frame=single]
foo = *bar;
*baz = 1;
\end{lstlisting}

donde \verb|foo| y \verb|bar| son variables, \verb|1| es un valor constante, ``\verb|=|'' indica una instrucción de asignación y ``\verb|*|'' corresponde al operador de desreferencia.

En la primera expresión \verb|*bar| se encuentra del lado derecho de la asignación, en este caso se quiere que \verb|*bar| produzca un valor que pueda ser luego asignado a \verb|foo|.
Por otra parte, en la segunda expresión \verb|*baz| se encuentra del lado izquierdo de la asignación, en este caso se quiere que \verb|*baz| produzca una dirección a la cual se le pueda asignar el valor \verb|1|.

Esto también ocurre con el acceso a arreglos.
Para modelar correctamente la semántica de las expresiones en Chloe, es necesario contar con esta distinción entre expresiones del lado izquierdo (\textit{l-values}) y expresioness del lado derecho (\textit{r-values}).
En las siguientes secciones al referirse a expresiones del lado derecho o \textit{r-values} se utilizará simplemente el nombre expresiones y se utilizará expresión del LHS (por sus siglas en ingles \textit{left-hand-side}) en lugar de \textit{l-values} o expresiones del lado izquierdo al referirse a dichas expresiones.
\begin{comment}
FIXME mosca! esto está mal traducido!
\end{comment}

Chloe soporta expresiones constantes, apuntadores a \textit{null} y variables, así como las siguientes operaciones sobre expresiones: suma, resta, menos unario, división, módulo, multiplicación, menor que, negación, conjunción, disyunción e igualdad.
También cuenta con una expresión \verb|New| que corresponde a una llamada a \verb|malloc| en C.
Tiene operadores de desreferencia, referencia y acceso a arreglos.
En C, estos son los operadores \verb|*|, \verb|&| y \verb|[]|, respectivamente.
Finalmente, como expresiones del LHS se tienen las operaciones de desreferencia y accesso a arreglos.
\begin{comment}
FIXME mosca! esto está mal traducido!
\end{comment}

\subsubsection*{Tipos}

En el lenguaje Chloe se tienen dos tipos; enteros y direcciones.
Se diferencia entre los valores de tipo entero y las direcciones con el fin de definir correctamente la semántica.
A continuación, se presentan los detalles de los dos tipos en el lenguaje Chloe.

\paragraph*{Enteros}

Se establecen los siguientes sinónimos entre tipos en Isabelle:

\begin{lstlisting}[frame=single]
type_synonym int_width = 64
type_synonym int_val = int_width word
\end{lstlisting}


El termino \verb|int_width| se refiere a la precisión del valor entero.
En el caso de este trabajo se supone un valor de 64 ya que se trabaja con una arquitectura de 64 bits.
Este parametro le indica a la semántica que debe suponer que se trabaja con una arquitectura de 64 bits donde los límites inferiores y superiores para un entero se definen en la figura~\ref{fig:int_bounds}.

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  abbreviation INT_MIN :: int where INT_MIN $\equiv$ - (2^(int_width - 1))
  abbreviation INT_MAX :: int where INT_MAX $\equiv$  ((2^(int_width - 1)) - 1)
  \end{lstlisting}

  \caption{Integer lower and upper bounds}
  \label{fig:int_bounds}
\end{figure}

Cuando se trabaja con una arquitectura diferente, este parametro puede ser cambiado con el fin de cumplir con los requerimientos de la arquitectura.

Tambien, los enteros se definen como palabras de longitud \verb|int_width| (en este caso \verb|64|).
Debido a que no se utiliza el tipo predefinido \verb|int| en Isabelle, para poder trabajar con palabras y soportar la generación de código para las mismas se utiliza la entrada \textit{Native Word} en el \textit{Archive of Formal Proofs}~\cite{Native_Word-AFP}.

De ahora en adelante se referirá a las palabras de longitud 64 que se utilizan para representar a los enteros en Chloe como simplemente enteros.
Es importante notar que, a menos de que sea explícitamente mencionado en el texto, por simplicidad se utilizará la palabra `entero' para referirse a las palabras de longitud 64 en lugar del tipo predefinido \verb|int| en Isabelle.

\paragraph*{Direcciones}

Se define el siguiente tipo de datos en Isabelle para representar direcciones:

\begin{lstlisting}[frame=single, mathescape=true]
datatype addr = nat $\times$ int
\end{lstlisting}

Una dirección es entonces un par compuesto por un número natural y un entero (el cual es de tipo \verb|int| predefinido en Isabelle), estos representan un par \verb|(id_bloque, desplazamiento)|.
En secciones futuras se procederá a explicar el diseño de la memoria.

\subsubsection*{Valores}

Los valores para una expresión se definen de la siguiente forma:

\begin{lstlisting}[frame=single, mathescape=true]
datatype val = NullVal | I $int\_val$ | A $addr$
\end{lstlisting}

donde \verb|NullVal| corresponde a un apuntador a \textit{null}, \verb|I| $int\_val$ corresponde a un valor entero y \verb|A| $addr$ corresponde al valor de una dirección.
Al evaluar una expresión se puede obtener cualquiera de estos tres valores.

\subsubsection*{Memoria}

Se modela la memoria dinámica de la siguiente manera:

\begin{lstlisting}[frame=single, mathescape=true]
type_synonym mem = val option list option list
\end{lstlisting}

La memoria se encuentra representada como una lista de bloques asignados y cada uno de estos bloques consta de una lista de celdas con los valores en memoria.
Por cada bloque hay dos posibilidades: un bloque asignado o un bloque no asignado, esto es modelado por el uso del tipo \verb|option|, donde \verb|Some| $l$ (donde $l$ es de tipo \verb|val option list|) denota un bloque asignado y \verb|None| uno sin asignar.
Cada bloque se compone de una lista de celdas que contienen los valores en memoria.
Cada celda puede tener diferentes valores dependiendo de si se encuentra sin inicializar o si posee un valor.
Una celda sin sin inicializar en memoria está representada por el valor \verb|None|.
Mientras que una celda que posee un valor está representada por el valor \verb|Some| $v$ (donde $v$ es de tipo \verb|val|).
Este modelo de memoria está inspirado en el trabajo de Blazy y Leroy~\cite{leroy-blazy-memory-model}, es un modelo simplificado que fue ajustado para satisfacer las necesidades de este trabajo.

Existen cuatro operaciones principales para la gestión de memoria, estas son \verb|new_block|, \verb|free|, \verb|load| y \verb|store| y se encuentran especificadas en la figura~\ref{fig:mem_operations}.
Cada una de estas operaciones puede fallar, por lo que su tipo de retorno es $\tau\ \verb|option|$.
Los valores de ese tipo son \verb|None| cuando la operación falla y $\verb|Some|(v)$ cuando es exitosa (donde $v$ es de tipo $\tau$).

Las funcionalidades de las operaciones de gestión de memoria se describen a continuación:

\begin{itemize}
  \item{\verb|new_block| es la función que se encarga de asignar un nuevo bloque de memoria dinámica de un tamaño determinado.
    Esta función fallará en el caso donde el tamaño dado sea menor o oigual a cero, también puede fallar si un valor de un tipo diferente a entero es dado.
    Al ser ejecutada exitosamente, la función retorna la dirección de inicio del nuevo bloque junto con la memoria modificada.}
  \item{\verb|free| es la función que se encarga de liberar un bloque de memoria dinámica.
    Esta función fallará en el caso donde la dirección dada no sea válida en memoria.
    Al ser ejecutada exitosamente, la función retorna un nuevo estado que incluye la memoria actualizada.}
  \item{\verb|load| es la función que, dada una dirección, retorna el valor almacenado en la celda de memoria denotada por la dirección dada.
    Esta función fallará en el caso donde la dirección dada no sea válida en memoria.
    Al ser ejecutada exitosamente, la función retornará el valor almacenado en memoria.}
  \item{\verb|store| es la función que, dada una dirección y un valor, almacena dicho valor en la celda de memoria denotada por la dirección dada.
    Esta función fallará en el caso donde la dirección dada no sea válida en memoria.
    Al ser ejecutada exitosamente, la función retorna un nuevo estado que incluye la memoria actualizada.}
\end{itemize}

\begin{figure}
  \begin{lstlisting}[mathescape=true, frame=single]
  new_block :: val $\Rightarrow$ mem $\Rightarrow$ (val $\times$ mem) option
  free      :: addr $\Rightarrow$ val  $\Rightarrow$ visible_state $\Rightarrow$ visible_state option
  load      :: addr $\Rightarrow$ mem $\Rightarrow$ val option
  store     :: addr $\Rightarrow$ val  $\Rightarrow$ visible_state $\Rightarrow$ visible_state option
  \end{lstlisting}

  \caption{Operaciones de manejo de memoria}
  \label{fig:mem_operations}
\end{figure}

Es importante tener en cuenta que las únicas razones por las que la asignación de memoria dinámica puede fallar en la semántica son aquellas descritas anteriormente.
Debido a que se supone que la memoria es ilimitada, no existirá un caso donde una llamada a \verb|new| falle debido a falta de memoria.

Sin embargo, como los recursos de una máquina son limitados, no se puede utilizar una cantidad ilimitada de memoria.
Aquí es donde se consigue una discrepancia con lo descrito por el estándar de C.
Cuando se realiza una llamada a malloc en un programa en C, existe una posibilidad de que la llamada retorne \verb|NULL|.
En tal caso esta semántica y la descrita por el estándar de C actúan de manera diferente.

Una opción para poder modelar una función de asignación de memoria que presente este tipo de comportamiento, es decidir de manera no determinística cuando esta función puede retornar \verb|null|.
El problema con esta opción es que complicaría el proceso de demostración de propiedades de un programa ya que cualquier llamada a la función de asignación de memoria dinámica podría fallar.
Otra opción sería suponer que se cuenta con una cantidad fija de memoria está disponible.
Sin embargo, modelar este tipo de función no es una tarea trivial y permanece fuera del alcance de este trabajo.

Por lo tanto, en este trabajo se supone que se cuenta con una cantidad ilimitada de memoria y luego, cuando el proceso de traducción se lleva a cabo, se envuelve la función \verb|malloc| de C en una función definida por el usuario que verifica si la llamada a \verb|malloc| fue exitosa o no.
Lo que se puede garantizar sobre un programa generado es que o bien se generará y tanto la ejecución del mismo en el ambiente de Isabelle como la ejecución en la máquina producirán estados finales que son equivalentes o el programa abortará si un error por falta de memoria es encontrado.


\subsection{Semántica}\label{subsection:semantics_expressions}

La semántica de una expresión es su valor y el efecto que evaluar la misma tiene sobre el estado del programa.
Para expresiones tales como $21 + 21$, la evaluación de la misma es trivial ($42$).
Por otra parte, cuando se tienen expresiones con variables, tales como $foo + 42$, entonces se depende del valor de la variable.
Por lo tanto se deben conocer el valor de una variable al momento de ejecución.
Estos valores se almacenan en el estado del programa.

El estado de un programa es realmente un poco mas complicado que lo que se presenta a continuación.
Aunque la sección~\ref{section:states} se dedica exclusivamente a discutir los estados, se procede a describir en esta sección las partes el estado que son necesarias para discutir la semántica de las expresiones en Chloe.

\paragraph*{Valuaciones}\label{paragraph:valuation}

Se define el tipo para una valuación de la siguiente manera:

\begin{lstlisting}[frame=single, mathescape=true]
type_synonym valuation = vname $\Rightarrow$ val option option
\end{lstlisting}

Una valuación es una función que mapea un nombre de una variable a un valor.
El tipo de retorno es \verb|val option option|, lo que modela los siguientes estados para el valor de una variable: no definida, no inicializada y posee un valor.
Por lo tanto, dado un nombre de una variable, esta función puede producir uno de los siguientes resultados:

\begin{itemize}
  \item{\verb|None|, que representa una variable que no está definida.}
  \item{\verb|Some None|, que representa una variable que está definida pero no ha sido inicializada.}
  \item{\verb|Some| $v$, que representa una variable que está definida e inicializada y contiene el valor v.}
\end{itemize}

\paragraph*{Estados visibles}\label{paragraph:visible_state}

Cuando se ejecuta un comando, el mismo solo puede \textit{ver} cierta parte del estado.
La parte de un estado que un comando puede ver es aquella que contiene las variables que son locales a la función que se está ejecutando, las variables globales y la memoria.
Esta parte del estado es precisamente lo que se llama \textit{estado visible}.
Se puede definir un estado visible como la parte de un estado que un comando puede ver y modificar.
El tipo definido para ellos es el siguiente:

\begin{lstlisting}[frame=single, mathescape=true]
type_synonym visible_state = valuation $\times$ valuation $\times$ mem
\end{lstlisting}

Un estado visible es una tupla que contiene una función de valuación para las variables locales, una función de valuación para las variables globales y la memoria dinámica del programa.

\paragraph*{}
Ahora se puede introducir la semántica para las expresiones en Chloe.
Como fue expresado antes, la semántica de una expresión es su valor y el efecto que tiene la misma sobre el estado de un programa, por lo tanto se definen dos funciónes de evaluación, una que calcula el valor de una expresión y una que calcula el valro de una expresión del LHS.
Estas funciones se definen de la siguiente manera:

\begin{lstlisting}[frame=single, mathescape=true]
eval   :: exp $\Rightarrow$ visible_state $\Rightarrow$ (val $\times$ visible_state) option
eval_l :: lexp $\Rightarrow$ visible_state $\Rightarrow$ (addr $\times$ visible_state) option
\end{lstlisting}

donde \verb|eval|, dada una expresión y un estado visible, retornará el valor de esta expresión y el estado visible resultante de evaluar dicha expresión.
La función \verb|eval_l|, dada una expresión del LHS y un estado visible, retornará el valor de esta expresión (el cual debe ser una dirección) y el estado resultante luego de evaluar dicha expresión.
Es importante tener en cuenta que el tipo de retorno de las funciones de evaluación es el tipo \verb|option|.
Esto es debido a que estas funciones pueden fallar.
Un fallo puede ocurrir en cualquier momento al evaluar una expresión y si un fallo es encontrado entonces el mismo se propaga hasta que toda la evaluación de la expresión devuelva un valor \verb|None| que indica un error en la evaluación.

La evaluación de una expresión puede fallar por diversas razones que incluyen, pero no están limitadas a, variables no definidas, operandos ilegales en operaciones, acceso a partes inválidas de memoria y \textit{overflow}.
Por lo tanto, si hay un error temprano en la semántica de evaluación de expresiones, será detectado y propagado como un valor \verb|None| que indica un estado erróneo.

Las funciones \verb|eval| y \verb|eval_l| dependen de otras funciones definidas con el find e calcular correctamente los valores de las expresiones.
La definición de todas las funciones auxiliares para \verb|eval| y \verb|eval_l| se encuentra en la figura~\ref{fig:aux_fun_eval}.
A excepción de \verb|div_towards_zero| y \verb|mod_towards_zero|, cada una de estas operaciones pueden fallar, por lo que su tipo de retorno es $\tau$ \verb|option|.
Los valores de este tipo son o \verb|None| cuando la operación falla o $\verb|Some|(v)$ donde $v$ es de tipo $\tau$.

\begin{figure}
  \begin{lstlisting}[mathescape=true, frame=single]
  detect_overflow  :: int $\Rightarrow$ val option
  read_var         :: vname $\Rightarrow$ visible_state $\Rightarrow$ val option
  plus_val         :: val $\Rightarrow$ val $\Rightarrow$ val option
  subst_val        :: val $\Rightarrow$ val $\Rightarrow$ val option
  minus_val        :: val $\Rightarrow$ val option
  div_towards_zero :: int $\Rightarrow$ int $\Rightarrow$ int
  div_val          :: val $\Rightarrow$ val $\Rightarrow$ val option
  mod_towards_zero :: int $\Rightarrow$ int $\Rightarrow$ int
  mod_val          :: val $\Rightarrow$ val $\Rightarrow$ val option
  mult_val         :: val $\Rightarrow$ val $\Rightarrow$ val option
  less_val         :: val $\Rightarrow$ val $\Rightarrow$ val option
  not_val          :: val $\Rightarrow$ val option
  to_bool          :: val $\Rightarrow$ bool option
  eq_val           :: val $\Rightarrow$ val $\Rightarrow$ val option
  new_block        :: val $\Rightarrow$ mem $\Rightarrow$ (val $\times$ mem) option
  load             :: addr $\Rightarrow$ mem $\Rightarrow$ val option
  \end{lstlisting}

  \caption{Funciones auxiliares para eval y eval\_l}
  \label{fig:aux_fun_eval}
\end{figure}

Las funcionalidades de las funciones auxiliares son las siguientes:

\begin{itemize}
\item{La función \verb|detect_overflow| detecta el \textit{overflow} en enteros.
Toma como parametro un valor del tipo entero predefinido por Isabelle y chequea si existe \textit{overflow}con los límites mostrados en la figura~\ref{fig:int_bounds}.
Esta función fallará cuando se detecte \textit{overflow}.
Al ser ejecutada exitosamente, la función retorna el valor correspondiente al entero dado como parámetro.}

\item{La función \verb|read_var| calcula el valor de una variable.
Esta función falla cuando el nombre de la variable dado como parámetro corresponde a una variable no definida.
Al ser ejecutada exitosamente, la función retorna el valor de la variable.
Con el fin de calcular el valor de dicha variable, esta función chequea la valuación de las variables locales en el estado visible y retorna el valor de la variable si se encuentra definida allí.
En el caso en el que la variable no se encuentre definida en el alcance local, la función procederá a chequear el alcance global y retornará el valor de la variable.}

\item{La función \verb|plus_val| calcula el valor de la suma entre dos valores.
Esta función falla cuando se detecta \textit{overflow} o cuando operandos distintos a dos enteros o una dirección y un entero (en ese orden específico) son dados como parametros a la función.
Al ser ejecutada exitosamente con dos valores de tipo entero como parámetros, la función retorna un valor entero correspondiente a la suma de los operandos.
Al ser ejecutada exitosamente con una dirección y un entero como parámetros, la función retorna una dirección correspondiente a la suma del desplazamiento entero al valor original de la dirección.}

\item{La función \verb|subst_val| calcula el valor de una sustracción entre dos valores.
Esta función falla cuando se detecta \textit{overflow} o cuando operandos distintos a dos enteros o una dirección y un entero (en ese orden específico) son dados como parametros a la función.
Al ser ejecutada exitosamente con dos valores de tipo entero como parámetros, la función retorna un valor correspondiente a la resta de los operandos.
Al ser ejecutada exitosamente con una dirección y un entero como parámetros, la función retorna una dirección correspondiente a la resta del desplazamiento entero al valor original de la dirección.}

\item{La función \verb|minus_val| calcula el valor de la operación de menos unario sobre un valor.
Esta función falla cuando se detecta \textit{overflow} o cuando un operando distinto a un entero es dado.
Al ser ejecutada exitosamente, la función retorna un valor entero correspondiente al resultado de negar el valor dado como parámetro.}

\item{La función \verb|div_towards_zero| realiza la división entera con truncamiento hacia cero.}

\item{La función \verb|div_val| calcula el valor de la división entre dos valores.
La función falla cuando se detecta \textit{overflow} o una división por cero o cuando operandos distintos a dos enteros son dados como parámetros a la función.
Al ser ejecutada exitosamente, la función retorna un valor entero correspondiente al resultado de la división entera entre los dos operandos.}

\item{La función \verb|mod_towards_zero| realiza la operación de módulo con truncamiento hacia cero.}

\item{La función \verb|mod_val| calcula el valor de la operación módulo entre dos valores.
La función falla cuando se detecta \textit{overflow} o una división por cero o cuando operandos distintos a dos enteros son dados como parámetros a la función.
Al ser ejecutada exitosamente, la función retorna un valor entero correspondiente al resultado de la operación de módulo entre los dos operandos.}

\item{La función \verb|mult_val| calcula el valor de la multipliación entre dos valores.
La función falla cuando se detecta \textit{overflow} o cuando operandos distintos a dos enteros son dados como parametros a la función. 
Al ser ejecutada exitosamente, la función retorna un valor entero correspondiente a la multiplicación de los operandos de la función.}

\item{La función \verb|less_val| calcula el valor resultante de realizar la operación menor que entre dos valores.
La función falla cuando operandos distintos a dos enteros son dados como parámetros a la función.
Al ser ejecutada exitosamente, la función retorna un valor entero \verb|I| $1$ cuando el primer operando es menor que el segundo y un valor entero \verb|I| $0$ de lo contrario.}

\item{La función \verb|not_val| calcula el valor resultante de realizar la negación lógica sobre un valor.
La función falla cuando un operando distinto a un entero es dado como parámetro.
Al ser ejecutada exitosamente, la función retorna un valor entero \verb|I| $1$ cuando el operando dado es un entero de valor \verb|I| $0$ y retorna un valor entero \verb|I| $0$ cuando el operando dado es un entero de valor diferente de \verb|I| $0$.}

\item{La función \verb|to_bool| retorna un valor de tipo booleano predefinido en Isabelle dado un operando.
La función se utiliza para calcular evaluación de corto circuito para las operaciones \verb|And| y \verb|Or|.
La función falla cuando un operando distinto a un entero es dado como parámetro.
Al ser ejecutada exitosamente, la función retorna \verb|False| cuando el parámetro dado tiene un valor igual a \verb|I| $0$ y retorna \verb|True| de lo contrario.}

\item{La función \verb|eq_val| calcula el valor resultante de relizar la comparación de igualdad entre dos valores.
La función falla cuando operandos diferentes a dos enteros o dos direcciones son dados como parámetros.
Al ser ejecutada exitosamente con dos valores enteros como parámetros, la función retorna un valor entero \verb|I| $1$ si ambos operandos son iguales y un valor entero \verb|I| $0$ de lo contrario.
Al ser ejecutada exitosamente con dos direcciones como parámetros, la función retorna un valor entero \verb|I| $1$ si ambas direcciones son iguales y un valor entero \verb|I| $0$ de lo contrario.
Dos direcciones son consideradas como iguales cuando ambos componentes de la tupla son iguales.}

\item{Las funciones \verb|new_block| y \verb|load| son aquellas explicadas anteriormente en la sección~\ref{subsection:syntax_expressions} que se encargan de asignar un nuevo bloque de memoria y cargar un valor desde memoria, respectivamente.}
\end{itemize}


\section{Comandos}\label{section:commands}

En la siguiente sección se discutirá la sintaxis y semántica de los comandos en Chloe, así como las funciones y los programas escritos en el lenguaje.
Ademas, se discutirán algunas suposiciones que la semantica toma que causan restricciones en la misma.

\subsection{Sintaxis}\label{subsection:syntax_commands}

Chloe contiene los siguientes constructores: asignación, secuenciación, condicionales, ciclos, SKIP\footnote{El comando SKIP es el equivalente a noop ya que no realiza operación algna. Se utiliza con el fin de poder expresar otros constructores sintácticos como lo es un condicional sin una rama ELSE}, liberación de memoria, instrucción \verb|return| y funciones.
Las expresiones son aquellas descritas en la sección anterior (~\ref{section:expressions}).

Aquí se procede a describir la \textit{sintaxis abstracta} de loc omandos en el lenguaje Chloe.

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  type_synonym fname = string

  datatype
    com = SKIP
        | Assignl lexp exp
        | Assign  vname exp
        | Seq     com  com
        | If      exp com com
        | While   exp com
        | Free    lexp
        | Return exp
        | Returnv
        | Callfunl lexp fname "exp list"
        | Callfun vname fname "exp list"
        | Callfunv fname "exp list"
  \end{lstlisting}

  \caption{Comandos en Chloe}
  \label{fig:chloe_commands}
\end{figure}

En la figura~\ref{fig:chloe_commands} se encuentra la definición del tipo de datos creado en Isabelle para los comandos, donde \verb|lexp| y \verb|exp| son las expresiones descritas en la sección anterior (~\ref{section:expressions}), \verb|vname| representa los nombres de variables y \verb|fname| representa los nombres de funciones.

Para la asignación se definen dos comandos diferentes, uno de ellos permite la asignación a una variable, mientras que el otro permite la asignación a una ubicación en memoria.
Se necesitan ambos comandos dado que el dominio definidos para las direcciones y los valores enteros es disjunto, por lo tanto, una dirección no puede representar un valor entero y viceversa.

También se tienen dos comandos de retorno, uno de ellos permite retornar de una funcion que posee un valor de retorno, mientras que el otro es para retornar de una función que no lo posee.

Finalemnte, se tienen tres comandos diferentes para llamadas a funciones.
Uno de ellos (\verb|Callfunv|) es para funciones que no poseen un valor de retorno.
Los otros dos dependen de lo que se haga con el valor de retorno de la función, si el valor de retorno debe ser asignado a una variable se utiliza el comando \verb|Callfun| y si el retorno debe ser asignado a una celda en memoria se utiliza el comando \verb|Callfunl|.

En Isabelle se define una sintaxis concreta, la cual facilita la escritura y lectura de comandos en Chloe.
En la tabla~\ref{tab:concrete_syntax} se introduce la sintaxis concreta suponiendo que se tiene $x$ que representa nombres de variables, $a$ que representa expresiones, $c$, $c_1$ y $c_2$ que representan comandos, $y$ que representa expresiones del LHS y $f$ que representa nombres de funciones.
A lo largo del trabajo se continuará utilizando la sintaxis concreta para facilitar la legibilidad.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
  \hline
  \textbf{Sintaxis abstracta} & \textbf{Sintaxis concreta} \\ [0.5ex]
  \hline \hline
  \verb|Assignl| $y$ $a$ & $y$ \verb|::==| $a$ \\
  \verb|Assign| $x$ $a$ & $x$ \verb|::=| $a$ \\
  \verb|If| $a\ c_{1}\ c_{2}$ & \verb|IF| $a$ \verb|THEN| $c_{1}$ \verb|ELSE| $c_{2}$ \\
  \verb|While a| $c$ & \verb|WHILE| $a$ \verb|DO| $c$ \\
  \verb|Free| $y$ & \verb|FREE| $y$ \\
  \verb|Return| $a$ & \verb|RETURN| $a$ \\
  \verb|Returnv| & \verb|RETURNV| \\
  \verb|Calllfunl| $y\ f\ [a]$ & $y$ \verb|::==| $f$ \verb|(| $[a]$ \verb|)| \\
  \verb|Calllfun| $x\ f\ [a]$ & $x$ \verb|::=| $f$ \verb|(| $[a]$ \verb|)| \\
  \verb|Calllfunv| $f\ [a]$ & \verb|CALL| $f$ \verb|(| $[a]$ \verb|)| \\
  \hline
\end{tabular}

\caption{Equivalencia entre sintaxis abstracta y concreta}
\label{tab:concrete_syntax}
\end{table}


\section{Funciones}\label{section:functions_commands}

En Chloe se tienen funciones que devuelven valores y aquellas que no tienen valor de retorno.
Para las funciones que devuelven un valor es necesario saber que ocurre con ese valor de retorno.
Al retornar de una llamada a función, el valor de retorno o bien debe ser asignado a una variable o a una celda en memoria o debe ser ignorado.
En esta sección no se entrará en detalles para explicar esta decisión de diseño sino que se retrasará hasta la sección~\ref{subsection:cfg} donde se podrá explcar el razonamiento detras de esta decisión de una manera mas adecuada.

Como es visible en la definición de la figura~\ref{fig:fun_def}, una función consiste en un nombre, los parámetros formales, las variables locales y el cuerpo de la función, que es un comando, potencialmente grande, en el lenguaje Chloe.
También se define un predicado que comprueba si una declaración de una función es válida o no.
La declaración de una función se considera válida si y solo si los parámetros de la función y las variables locales tienen nombres distintos.

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  record fun_decl =
    name :: fname
    params :: vname list
    locals :: vname list
    body :: com

  valid_fun_decl :: fun_decl $\Rightarrow$ bool
  \end{lstlisting}

  \caption{Definiciones de funciones}
  \label{fig:fun_def}
\end{figure}

\section{Programas}\label{section:programs_commands}

Un programa en Chloe consiste en un nombre, una lista de variables globales y una lista de funciones.
En el apéndice~\ref{ap:prog_def} se encuentra la definición de un programa y su definición de validez.

Un programa se considera válido si cumple con todas las siguientes condiciones:

\begin{itemize}
  \item{Los nombres de las variables globales son distintos entre si.}
  \item{Los nombres de las funciones en el programa son diferentes entre si.}
  \item{Cada declaración de función para cada función en el programa debe ser válida.}
  \item{La función main debe estar definida.}
  \item{Ninguno de los nombres de las variables o nombres de funcion en el programa debe ser una palabra clave reservada del lenguaje C o una palabra clave reservada para \textit{testing}.\footnote{Dado que se quiere generar código C de la semántica de Chloe, se debe garantizar que ni los nombres de las variables ni de las funciones son alguna de las palabras claves reservadas en C o alguna de las palabras claves reservadas que se utilizan como nombres de variables en el proceso de \textit{testing}.}}
  \item{Las variables globales y los nombres de las funciones en un programa no pueden ser iguales.}
\end{itemize}


\begin{comment}

Pasada a anexos

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  record program =
    name :: string
    globals :: vname list
    procs :: fun_decl list

  reserved_keywords =
    [''auto'', ''break'', ''case'', ''char'', ''const'', ''continue'',
     ''default'', ''do'', ''double'', ''else'', ''enum'', ''extern'',
     ''float'', ''for'', ''goto'', ''if'', ''inline'', ''int'', ''long'',
     ''register'', ''restrict'', ''return'', ''short'', ''signed'',
     ''sizeof'', ''static'', ''struct'', ''switch'', ''typedef'',
     ''union'', ''unsigned'', ''void'', ''volatile'', ''while'',
     ''_Bool'', ''_Complex'', ''_Imaginary'']

  test_keywords =
    [''__test_harness_num_tests'', ''__test_harness_passed'',
     ''__test_harness_failed'', ''__test_harness_discovered'' ]

  definition valid_program :: program $\Rightarrow$ bool where
  valid_program p $\equiv$
      distinct (program.globals p)
    $\bigwedge$ distinct (map fun_decl.name (program.procs p))
    $\bigwedge$ ($\forall$ fd $\in$ set (progarm.procs p). valid_fun_decl fd)
    $\bigwedge$ ( let
         pt = proc_table_of p
       in
         ''main'' $\in$ dom pt
         $\bigwedge$ fun_decl.params (the (pt ''main'')) = [])
   $\bigwedge$ ( let
         prog_vars = set ((program.globals p) @
           collect_locals (program.procs p));
         proc_names = set (map (fun_decl.name) (program.procs p))
       in
         ($\forall$ name $\in$ prog_vars.
           name $\notin$ set (reserved_keywords @ test_keywords)) $\bigwedge$
         ($\forall$ name $\in$ proc_names.
           name $\notin$ set (reserved_keywords @ test_keywords)) $\bigwedge$
         ($\forall$ fname $\in$ proc_names.
           ($\forall$ vname $\in$ set (program.globals p). fname $\neq$ vname)))
  \end{lstlisting}

  \caption{Definiciones de un programa}
  \label{fig:prog_def}
\end{figure}

\end{comment}


\section{Restricciones}\label{subsection:restrictions_commands}

Esta semántica hace una suposición con respecto a la máquina en la que el código va a ser ejecutado.
Esta restricción está parametrizada y corresponde a la arquitectura de la máquina en la que el código será ejecutado.
Como se dijo anteriormente, la precisión de los valores enteros puede ser modificada con el fin de hacer que esta semántica sea compatible con diferentes arquitecturas, por ejemplo arquitecturas de 32 bits.

Las suposiciones hechas por esta semántica pueden ser cambiadas al cambiar el parámetro \verb|int_width|, el cual cambiará automáticamente los límites superior e inferior que se tienen para enteros (estos límites se describen en la figura~\ref{fig:int_bounds}).

Con el fin de garantizar las suposiciones hechas por la semántica, más adelante en el proceso de generación de código, se generan aserciones que aseguran que las condiciones que se suponen se cumplan.

Otra restricción en la semántica es que solo funciona para un subconjunto de C donde la semántica es determinística y cualquier comportamiento indefinido se considera como un error en la semántica.
Se pasará a un estado erróneo si la semántica encuentra comportamiento que sea considerado como indefinido por el documento de referencia del lenguaje C~\cite{c99}, un ejemplo de este tipo de comportamiento es \textit{overflow} de enteros.


\section{Estados}\label{section:states}

En lenguajes más simples, que solo admiten un conjunto limitado de características tales como asinación, secuenciación de instrucciones, condicionales, ciclos y valores enteros, la representación del estado consite simplemente en una función que mapea los nombres de variables a valores.
En Chloe ese no es el caso, al incluir funciones, memoria dinámica y apuntadores al conjunto de características admitidas, la representación del estado del programa deja de ser una simple función que mapea nombres de variables a valores.
En esta sección se detallan los componentes de la represntación de un estado.
Anteriormente, en la sección~\ref{subsection:semantics_expressions} se explico el concepto de un ``estado visible'', aquí se aclara la diferencia entre ese estado visible y un estado real, también se detallan los componentes del estado de un programa.

\subsection{Valuación}\label{subsection:valuation}

Como se menciono anteriormente, una valuación es simplemente una función que mapea nombres de variables a valores.
El tipo de retorno para esta función es \verb|val option option| que se encarga de modelar tres estados diferentes que puede tener una variable: no definida, no inicializada o posee un valor.


\subsection{Pila de ejecución}\label{subsection:stack}

Chloe admite llamadas a funciones, para poder hacerlo se debe mantener una pila de ejecución en el estado.
Esta pila de ejecución (de ahora en adelante se referirá a la misma simplemente como la pila) consiste en una lista de marcos de pila.
Cada uno de estos marcos de pila contiene información importante acerca de la llamada a la función actual.

En la figura~\ref{fig:stack_def} el tipo definido para un marco de pila es una tupla que contiene un comando en Chloe, una valuación y una ubicación de retorno.
El comando de Chloe corresponde al cuerpo de la función a ejecutar.
La valuación corresponde a las variables locales a la función que fue llamada.
Finalmente, la ubicación de retorno puede ser una de las siguientes: una dirección, una variable o una ubicación de retorno inválida.
Cuando una función retorna una variable pueden suceder varias cosas:
\begin{itemize}
  \item{El valor se asigna a una variable.
  Esto es indicado por la ubicación de retorno correspondiente a una variable.}
  \item{El valor se asigna a una celda en memoria.
  Esto es indicado por la ubicación de retorno correspondiente a una dirección.}
  \item{El valor es ignorado.
  Esto es indicado por la ubicación de retorno inválida.}
\end{itemize}

También se utiliza la ubicación de retorno inválida para las funciones que no poseen un valor de retorno.

La ubicación de retorno se encuentra en el marco de pila del llamador, es decir, al retornar de una función el marco del llamador es el que debe ser revisado para saber a donde asignar el valor de retorno o si un valor de retorno es esperado.
Para aclarar esto podemos tomar el ejemplo de código en la figura~\ref{fig:stack_example}.
Es un programa sencillo donde una función que suma el valor de sus dos parámetros se define y luego se llama desde la función main.
Antes de la llamada a función, el marco de pila perteneciente a la función main tiene una ubicación de retorno $Invalid$ y luego de la llamada a función la ubicación de retorno cambia a la variable $x$.
Observe que el marco de pila que cambia su ubicación de retorno es aquel correpondiente a main, esto es porque el llamador es el que debe guardar la ubicación de retorno donde espera guardar el valor de retorno de una función llamada.
Una ubicación de retorno $Invalid$ indica que el llamador no espera guardar resultado alguno, es decir, el llamador no ha llamado aun a alguna función o la función llamada no tiene valor de retorno.

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  datatype return_loc = Ar addr | Vr vname | Invalid

  type_synonym stack_frame = com $\times$ valuation $\times$ return_loc
  \end{lstlisting}

  \caption{Stack definitions}
  \label{fig:stack_def}
\end{figure}

\begin{figure}
\centering
  \begin{subfigure}{0.3\textwidth}
  \begin{lstlisting}[mathescape=true]
  int sum(int a; int b){
    return a+b;
  }

  int main(){
    int x = 0;
    x = sum(2,2);
  }
  \end{lstlisting}
  \caption{Código de ejemplo en C}
  \label{fig:stack_ex_c_code}
  \end{subfigure}
  \begin{subfigure}{0.3\textwidth}
  \centering
    \begin{tabular}{|c|}
      \hline
      \hline
      $\vdots$ \\
      \\
      \hline
      $(x = \mathtt{sum}(2,2),$ \\
      $[x \mapsto 0],$ \\
      $ Invalid )$ \\
      \hline \hline
    \end{tabular}
  \caption{Pila antes de la llamada (crece hacia arriba)}
  \label{fig:stack_bef_fun_call}
  \end{subfigure}
  \begin{subfigure}{0.3\textwidth}
    \begin{tabular}{|c|}
      \hline
      \hline
      $\vdots$ \\
      \\
      \hline
      $(\mathtt{return}\ a+b,$ \\
      $[a \mapsto 2, b \mapsto 2],$ \\
      $ Invalid )$ \\
      \hline
      $(x = f(2,2),$ \\
      $[x \mapsto 0],$ \\
      $ x )$ \\
      \hline \hline
    \end{tabular}
  \caption{Pila luego de la llamada (crece hacia arriba)}
  \label{fig:stack_aft_fun_call}
  \end{subfigure}

  \caption{Ejemplo de convención de llamada}
  \label{fig:stack_example}
\end{figure}

\subsection{Tabla de procedimientos}\label{subsection:procedure_table}

Otra extensión que debemos agregar al tratar con funciones es una tabla de procedimientos.
Una tabla de procedimientos se define como sigue:

\begin{lstlisting}[mathescape=true, frame=single]
type_synonym proc_table = fname $\rightharpoonup$ fun_decl
\end{lstlisting}

donde ``$\rightharpoonup$ \verb|fun_decl|'' es equivalente a escribir ``$\Rightarrow$ \verb|fun_decl option|''.
Esta función mapea nombres de funciones a sus declaraciones.

Esta función se construye tomando la definición del programa y emparejando cada declaración de función en la lista a su nombre.
Cada programa tiene su propia tabla de procedimientos.


\subsection{Estado}\label{subsection:state}

Un estado se define como una tupla que contiene la pila, la valuación para las variables globales y la memoria dinámica.

\begin{lstlisting}[mathescape=true, frame=single]
type_synonym state = stack_frame list $\times$ valuation $\times$ mem
\end{lstlisting}

\subsection{Estado inicial}\label{subsection:initial_state}

Con el fin de construir un estado inicial se deben definir ciertos componentes.
En el apéndice~\ref{ap:prog_def} se encuentran definiciones para la configuración inicial de la pila, las variables globales y la memoria.
La configuración inicial para la pila consiste en la pila que contiene únicamente el marco de pila para la función main del programa.
La configuración inicial para la valuación global es una función donde cada posible nombre de variable se mapea al valor correspondiente a una variable no definida (\verb|None|).
La configuración inicial de la memoria dinámica es la memoria vacia, dado que nada ha sido asignado.

Luego de definir todos estso componentes, la configuracion del estado inicial es dada por la tupla que contiene la configuración inicial de la pila, las variables globales y la memoria dinámica.


\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  context fixes $program$ :: program begin

    private definition proc_table $\equiv$ proc_table_of program

    definition main_decl $\equiv$ the (proc_table ''main'')
    definition main_local_names $\equiv$ fun_decl.locals main_decl
    definition main_com $\equiv$ fun_decl.body main_decl

    definition initial_stack :: stack_frame list where
      initial_stack $\equiv$ [(main_com,
        map_of (map ($\lambda$. (x,None)) main_local_names),Invalid)]
    definition initial_glob :: valuation where
      initial_glob $\equiv$ map_of (map ($\lambda$. (x,None)) (program.globals program))
    definition initial_mem :: mem where initial_mem $\equiv$ []

    definition initial_state :: state where
      initial_state $\equiv$ (initial_stack, initial_glob, initial_mem)

  end
  \end{lstlisting}

  \caption{Construcción del estado inicial}
  \label{fig:init_state_building}
\end{figure}



\subsection{Estado visible}\label{subsection:visible_state}

Adicionalmente, se debe definir un estado visible (como se mencionó anteriormente en la sección~\ref{paragraph:visible_state}).
Al ejecutar una función transformadora\footnote{las funciones transformadoras se cubrirán más adelante en la sección~\ref{section:small_step}} sobre un estado (exceptuando las funciones transformadoras para las llamadas o retornos de funciones) la misma no podrá modificar alguna otra parte de la pila que no sea la valuación de variables locales del marco de pila actual.
Se definen las transformaciones reales en el contexto de estados visibles y luego se levanta esta definición a estados.
Por lo tanto, una función transformadora sobre estados, con excepción de las llamadas o retornos de funciones, no puede manipular la pila.

El marco de pila en el tope de la pila corresponde a la función actual que está siendo ejecutada y el comando en ese marco de pila corresponde al comando (o programa) en Chloe que está siendo ejecutado.
Cada vez que se ejecuta un comando o se toma un paso en la semántica de pasos cortos, este comando se actualiza para contener el próximo comando a ejecutar.
Con el fin de demostrar que la semántica de pasos cortos es determinística se debe demostrar que cada vez que se tiene una pila de ejecución no vacía, el orden en que se aplica el transformador de evaluación\footnote{Este transformador es la función eval levantada para trabajar en estados en lugar de estados visibles, se discutirá con mayor detalle en la sección~\ref{section:small_step}} y la función que actualiza el comando a ejecutar a continuación es irrelevante para el estado final resultante.
Es por ello que se introduce una definición separada para un estado visible aparte de la de un estado regular, es una vista del mismo estado completo pero con informacion limitada.

\section{Semántica de pasos cortos}\label{section:small_step}

\begin{comment}
add a little summary here.
\end{comment}

\subsection{CFG}\label{subsection:cfg}

Un Grafo de Control de Flujo (CFG por sus siglas en ingles \textit{Control Flow Graph}) es una representación en forma de grafo que cubre los diferentes caminos que un programa puede tomar durante su ejecución.
Se tiene el concepto de ubicación actual, que es un \textit{program pointer} a un nodo.
Un comando se ejecuta siguiendo una arista desde el nodo al que apunta el \textit{program pointer} a un nuevo nodo.
Los nodos del CFG son comandos.
Las aristas del CFG contienen una anotación con dos funciones que dependen del estado actual del programa.
La primera de estas funciones indica si una arista puede ser seguida o no (por ejemplo, en le caso de un condicional) y la segunda indica como será transformado el estado al seguir la arista, es decir, el efecto que tiene seguir la arista sobre el estado del programa.
Estas funciones son llamadas \textit{enabled} y \textit{transformer}.
A continuación se describen en detalle las definiciones para estas funciones.


\paragraph*{Enabled functions}\label{paragraph:enabled}

Una función \textit{enabled} es una función parcial que se define como sigue:

\begin{lstlisting}[mathescape=true, frame=single]
type_synonym enabled = state $\rightharpoonup$ bool
\end{lstlisting}

Indica si un estado está habilitado para continuar su ejecución.
Esta es una función parcial, por lo que su ejecución podría fallar.
La ejecución de una función \textit{enabled} falla cuando encuentra un error en su evaluación y retorna un valor \verb|None| que representa un estado erróneo.

Esta función es útil para la ejecución de construcciones condicionales en el lenguaje.

Si se tiene el término ``\verb|IF| $b$ \verb|THEN| $c_{1}$ \verb|ELSE| $c_{2}$''.
Cuando la evaluación de la condición $b$ produce un valor \verb|True| se seguirá aquella arista que lleva al nodo que contiene $c_1$.
Mientras que cuando la evaluación de $b$ produce un valor \verb|False| se seguirá aquella arista que lleva al nodo que contiene $c_2$.
Dependiendo del resultado de la función habilitada se decide que arista puede seguir el nodo.
El único caso donde una ejecución no podría continuar es cuando no hay ninguna arista habilitada que seguir.
Afortunadamente, esto no puede pasar en los programas de Chloe ya que siempre hay una arista habilitada.
A excepción del condicional, para cada comando en Chloe la función \textit{enabled} siempre retorna \verb|True|.
En el caso de un condicional, la ejecución puede continuar o bien siguiendo la arista hasta el primer comando o siguiendo la arista hasta el segundo comando.
Siempre habrá una arista que puede ser seguida luego de un nodo que contenga un condicional.

Una lista de las funciones \textit{enabled} que son utilizadas se presenta en la figura ~\ref{fig:enabled_def}.
La funcion \verb|truth_value_of| mapea un valor a un valor booleano, es decir \verb|True| o \verb|False|.
Tambien se encuentran las funciones \verb|en_always| que siempre retorna \verb|True|, \verb|en_pos| que solo retorna \verb|True| cuando el valor real (calculado con \verb|truth_value_of|) de una expresión dada como parámetro se evalúa como \verb|True| y \verb|en_neg| que solo retorna \verb|True| cuando el valor real (calculado con \verb|truth_value_of|) de una expresión dada como parámetro se evalua como \verb|False|.
Estas funciones serán utilizadas mas tarde en la definición del CFG.

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  fun truth_value_of :: val $\Rightarrow$ bool where
    truth_value_of NullVal $\longleftrightarrow$ False
  | truth_value_of (I $i$) $\longleftrightarrow$ $i$ $\neq$ $0$
  | truth_value_of (A _) $\longleftrightarrow$ True

  abbreviation en_always :: enabled where en_always $\equiv\ \lambda$_. Some True

  definition en_pos :: exp $\Rightarrow$ enabled

  definition en_neg :: exp $\Rightarrow$ enabled
  \end{lstlisting}

  \caption{Funciones \textit{enabled}}
  \label{fig:enabled_def}
\end{figure}


\paragraph*{Transformer functions}\label{paragraph:transformer}

Una función \textit{transformer} es una función parcial que se define como sigue:

\begin{lstlisting}[mathescape=true, frame=single]
type_synonym transformer = state $\rightharpoonup$ state
\end{lstlisting}

Es una función parcial que realiza una transformación de un estado a otro.
Dado que es una función parcial, su ejecución puede fallar.
La ejecución de una función \textit{transformer} falla cuando se encuentra un error en algún momento de su ejecución y retorna un valor \verb|None| que indica un estado erróneo.

Se definen funciones que producen una función \textit{transformer} para cada comando en Chloe.
Estas funciones serán utilizadas mas tarde en la definición del CFG y se definen en la figura~\ref{fig:transformer_def}.
Se define una función \textit{transformer} \verb|tr_id| que sirve como la función identidad y simplemente retorna el mismo estado que recibe como parámetro.

Las definiciones presentadas en la figura~\ref{fig:transformer_def} producen una función \textit{transformer} que será utilizada al ejecutar un comando.
Se procede a describir de una manera aproximada el efecto que tendrán estas funciones \textit{transformer} producidas al ser aplicadas a estados.

En primer lugar se tiene la función \textit{transformer} para una asignación producida por \verb|tr_assign|, se encarga de evaluar la expresión que se quiere asignar y luego realizar una operación \verb|write| al estado.
Retorna el estado resultante de realizar dicha evaluación y la operación \verb|write|.

El ``transformador'' para una asignación a una celda en memoria producida por \verb|tr_assignl|, se encarga de evaluar la expresión del LHS para obtener la ubicación de memoria donde se guardará el valor, evaluar la expresión para obtener el nuevo valor y guardar el valor en memoria.
Retorna el estado resultatnte de realizar dichas evaluaciones y la opración \verb|store|.

El ``transformador'' para una evaluación producido por \verb|tr_eval|, se encarga de evaluar una expresión.
Retorna el estado resultante de realizar dicha evaluación.

El ``transformador'' para una operación de liberación de memoria producido por \verb|tr_free|, se encarga de evaluar la expresión del LHS que recibe como parametro con el fin de obtener una dirección y liberar el bloque correspondiente a esta dirección en memoria.
Retorna el estado resultante de realizar dicha evaluación y la liberación de memoria.

Cuando se realiza una llamada a función se debe chequear que los parámetros formales y los parámetros reales dados a la función tengan el mismo tipo y que cada parámetro formal tenga un parámetro real correspondiente.
Dado que no se posee un sistema de tipos estático solamente se chequeara la segunda condición mencionada.
Ademas, el orden de evaluación de los parámetros dados a una función es de izquierda a derecha.
Los parámetros siempre se evaluan siguiendo un orden de derecha a izquierda.
Finalmente, cuando se llama a una función también se deben mapear los parámetros formales a los valores de los parámetros dados y considerarlos como variables locales en el alcance de la función.

Se tiene una función \verb|call_function| que produce un ``transformador'' para cualquier llamada a función, este ``transformador'' verifica que el número de parámetros formales y parámetros dados sea el mismo, evalua los parámetros dados de izquierda a derecha, crea un nuevo marco de pila que contiene el cuerpo de la función, la valuación de las variables locales (la cual incluye los parámetros mapeados a sus valores dados y las variables locales mapeadas al valor que representa no inicializado) y la ubicación de retorno \verb|Invalid|, retorna el estado resultante de realizar dichas operaciones sobre el estado.

Cuando se llama a una función, el llamador tiene que cambiar su marco de pila con el fin de actualizar el valor de la ubicación de retorno en el marco de pila actual.
Se definen diferentes funciones que realizan ese cambio dependiendo del tipo de llamada a función y producen un ``transformador'' llamando a \verb|call_function|.

Las diferentes funciones que se definen son \verb|tr_callfunl|, \verb|tr_callfun| y \verb|tr_callfunv|.
Se utiliza \verb|tr_callfunl| cuando la ubicación de retorno de una función es una celda en memoria.
En este caso, la función evalúa primero la expresión del LHS para obtener la dirección de retorno y la utiliza para actualizar la ubicación de retorno del marco de pila antes de llamar a \verb|call_function|.
El ``tranformador'' resultante retornará el estado resultante de realizar esta evaluación, actualizar el marco de pila y las operaciones hechas por \verb|call_function|.
Es importante resaltar que la evaluación de la expresión del LHS que retorna una dirección debe ser la primera que se realiza, esto es con el fin de evitar comportamiento no deseado, ya que la función llamada podría cambiar el estado.

Se utiliza \verb|tr_callfun| cuando la ubicación de retorno de la función es una variable.
En este caso la función actualiza la ubicación de retorno del marco de pila con el nombre de la variable antes de llamar a \verb|call_function|, el ``transformador'' resultante retornará el estado resultante de actualizar el marco de pila y las operaciónes hechas por \verb|call_function|.

Se utiliza \verb|tr_callfunl| cuando no se espera que la función llamada retorne un valor.
En este caso, la función actualiza la ubicación de retorno del marco de pila con \verb|Invalid| antes de llamar a \verb|call_function|, el ``transformador'' resultante retorna el estado resultante de actualizar el marco de pila y las operaciones hechas por \verb|call_function|.

Se tiene una función \verb|tr_return| que produce un ``transformador'' para una llamada a \verb|return| que retorna una expresión de una funcion, este ``transformador'' desempila el marco de pila en el tope de la pila (el cual pertenece a la función de la que se retorna), evalua el valor correspondiente a la expresión retornada y, si la pila no está vacía, busca el valor de retorno y dependiendo de si es una dirección, una variable o una ubicación \verb|Invalid| retorna el estado resultante de guardar el valor en memoria, guardar el valor en una variable o retornar el estado como estaba, respectivamente.
Nótese que si la función retorna un valor pero su ubicación de retorno es \verb|Invalid| entonces el valor retornado es ignorado en lugar de ser considerado como una ejecución errónea.

Finalmente, se tiene una función \verb|tr_return_void| que produce una función \textit{transformer} para una llamada a \verb|return| en una función que no retorna un valor.
Este ``transformador'' se encarga de desempilar el marco de pila en el tope de la pila (el cual pertenece a la función de la que se retorna).
Posteriormente, si la pila no está vacia, obtiene la ubicación de retorno.
Si la ubicación de retorno es una ubicación diferente de \verb|Invalid|, retorna un valor \verb|None| que indica un estado erróneo.
Sin embargo, si la ubicación de retorno es, en efecto, \verb|Invalid| entonces retorna el estado resultante de desempilar el último marco de pila.

\begin{comment}
FIXME
\end{comment}

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  abbreviation (input) tr_id :: transformer where tr_id $\equiv$ Some

  tr_assign :: vname $\Rightarrow$ exp $\Rightarrow$ transformer
  tr_assignl :: lexp $\Rightarrow$ exp $\Rightarrow$ transformer
  tr_eval :: exp $\Rightarrow$ transformer
  tr_free :: lexp $\Rightarrow$ transformer
  call_function :: proc_table $\Rightarrow$ fname $\Rightarrow$ exp list $\Rightarrow$ transformer
  tr_callfunl :: proc_table $\Rightarrow$ lexp $\Rightarrow$ fname $\Rightarrow$ exp list $\Rightarrow$ transformer
  tr_callfun :: proc_table $\Rightarrow$ vname $\Rightarrow$ fname $\Rightarrow$ exp list $\Rightarrow$ transformer
  tr_callfunv :: proc_table $\Rightarrow$ fname $\Rightarrow$ exp list $\Rightarrow$ transformer
  tr_return :: exp $\Rightarrow$ transformer
  tr_return_void :: transformer
  \end{lstlisting}

  \caption{Transformer functions}
  \label{fig:transformer_def}
\end{figure}


\paragraph*{CFG}

Para poder hablar de ejecuciones siguiendo las aristas del CFG se debe introducir un nuevo concepto.
Si se toma la definición de un CFG dada al inicio de esta sección, se tiene que para poder hablar de una ejecución de un comando siguiendo las aristas del CFG se debe tener un \textit{program pointer} que apunte al nodo actual.
También se debe introducir el concepto de una pila.
Se tiene una pila de \textit{program pointers} que acompaña el CFG y se desempilará un nuevo ``program pointer '' de la pila una vez que se haya \textit{seguido} el \textit{program pointer} actual hasta un nodo que contenga \verb|SKIP|.
Un \textit{program pointer} al cuerpo de una función se empilará cuando una llamada a función sea realizada.
Un \textit{program pointer} se desempilará de la pila cuando exista una instrucción \verb|return|.
Este concepto será importante al hablar de llamadas a funciones y retornos de funciones más adelante.

En el apéndice~\ref{ap:cfg_rules} se encuentra una definición inductiva para CFG, donde se pueden ver las reglas para formar aristas entre comandos.
Se puede seguir una arista en el CFG desde una asignación a una variable a \verb|SKIP|.
Esta arista siempre está habilitada (la función \textit{enabled} retorna \verb|True|) y la función \textit{transformer} para actualizar el estado es el resultado de llamar a \verb|tr_assign| con los parámetros específicos para el comando.

\begin{comment}

Pasado a apéndices

\begin{figure} 
  \begin{lstlisting}[frame=single, mathescape=true]
  type_synonym cfg_label = enabled $\times$ transformer

  inductive cfg :: com $\Rightarrow$ cfg_label $\Rightarrow$ com $\Rightarrow$ bool where

    Assign: cfg ($x$ ::= $a$) (en_always,tr_assign $x$ $a$) SKIP
  | Assignl: cfg ($x$ ::==  $a$) (en_always,tr_assignl $x$ $a$) SKIP
  | Seq1: cfg (SKIP;; $c_{2}$) (en_always, tr_id) $c_{2}$
  | Seq2: $[\![$cfg $c_{1}$ $a$ $c_{1}'$ $]\!]$ $\Longrightarrow$ cfg ($c_{1}$;; $c_{2}$) $a$ ($c_{1}'$;; $c_{2}$)
  | IfTrue: cfg (IF $b$ THEN $c_{1}$ ELSE $c_{2}$) (en_pos $b$, tr_eval $b$) $c_{1}$
  | IfFalse: cfg (IF $b$ THEN $c_{1}$ ELSE $c_{2}$) (en_neg $b$, tr_eval $b$) $c_{2}$
  | While: cfg (WHILE $b$ DO $c$) (en_always, tr_id)
      (IF $b$ THEN $c$;; WHILE $b$ DO $c$ ELSE SKIP)
  | Free: cfg (FREE $x$) (en_always, tr_free $x$) SKIP

  | Return: cfg (Return $a$) (en_always, tr_return $a$) SKIP
  | Returnv: cfg Returnv (en_always, tr_return_void) SKIP

  | Callfunl: cfg (Callfunl $e$ $f$ params)
      (en_always, tr_callfunl proc_table $e$ $f$ params) SKIP
  | Callfun: cfg (Callfun $x$ $f$ params)
      (en_always, tr_callfun proc_table $x$ $f$ params) SKIP
  | Callfunv: cfg (Callfunv $f$ params)
      (en_always, tr_callfunv proc_table $f$ params) SKIP
  \end{lstlisting}

  \caption{Reglas del CFG}
  \label{fig:cfg_rules}
\end{figure}

\end{comment}

Del mismo modo, una arista del CFG puede ser seguida desde una asignación a una celda en memoria hasta \verb|SKIP|, esta arista siempre está habilitada (la función \textit{enabled} retorna \verb|True|) y la función \textit{transformer} para actualizar el estado es el resultado de llamar a \verb|tr_assignl| con los parámetros específicos para el comando.

Para la secuenciación de instrucciones existen dos aristas diferentes que pueden ser seguidas.
Cuando el primer comando en la secuenciación es \verb|SKIP|, se puede seguir una arista que va desde el nodo con el comando completo hasta el nodo que tiene solamente el segundo comando.
Esta arista siempre está está habilitada (la función \textit{enabled} retorna \verb|True|) y la función \textit{transformer} para actualizar el estado es \verb|tr_id|.
El segundo caso ocurre cuando se tiene un comando de la forma \verb|(| $c_{1}$ \verb|;;| $c_{2}$ \verb|)| donde $c_{1}$ no es \verb|SKIP|.
Si es posible seguir una arista desde $c_{1}$ hasta otro nodo $c_{1}'$ (donde dicha arista está anotada con $a$, que es una tupla que contiene una función \textit{enabled} y una función \textit{transformer}) entonces es posible seguir una arista (también anotada con $a$) desde \verb|(| $c_{1}$ \verb|;;| $c_{2}$ \verb|)| hasta \verb|(| $c_{1}'$ \verb|;;| $c_{2}$ \verb|)|.

Para un condicional también se tienen dos casos.
Se tendrá la posibilidad de seguir una arista hacia el primer comando u otra arista hacia el segundo comando, dependiendo del valor de la condición.
En el caso donde se sigue la arista que lleva hasta el primer comando, se va desde \verb|IF| $b$ \verb|THEN| $c_{1}$ \verb|ELSE| $c_{2}$ hasta $c_{1}$.
Esta arista estará anotada con una función \textit{enabled} dada por \verb|en_pos| que solo habilitará esta arista cuando la condición $b$ se evalúe a \verb|True| y una función \textit{transformer} dado por \verb|tr_eval|.
En el caso donde se sigue la arista que lleva hasta el segundo comando, se va desde \verb|IF| $b$ \verb|THEN| $c_{1}$ \verb|ELSE| $c_{2}$ hasta $c_{2}$.
Esta arista estará anotada con una función \textit{enabled} dada por \verb|en_neg| que solo habilitará esta arista cuando la condición $b$ se evalúe a \verb|False| y una función \textit{transformer} dado por \verb|tr_eval|.

En el caso de un ciclo siempre se puede seguir una arista que va desde \verb|WHILE| $b$ \verb|DO| $c$ hasta \verb|IF| $b$ \verb|THEN| $c$ \verb|;; WHILE| $b$ \verb|DO| $c$ \verb|ELSE SKIP| al expandir la defición del ciclo una vez.
La arista tendrá una función \textit{enabled} que siempre está habilitada y la función \textit{transformer} para el estado es \verb|tr_id|.

Se puede seguir una arista desde \verb|FREE| $X$ hasta \verb|SKIP|.
Esta arista siempre está \textit{enabled} y tiene una función \textit{transformer} dado por \verb|tr_free| llamado con $x$.

Se puede seguir una arista desde cualquiera de los dos comandos de retorno existentes hasta \verb|SKIP|.
Esta arista siempre está habilitada (la función \textit{enabled} retorna \verb|True|) y tiene una función \textit{transformer} dado como resultado de \verb|tr_return| o \verb|tr_return_void| dependiendo de que comando de retorno sea.
Nótese que al \textit{ejecutar} este comando en el CFG, seguir una arista desde un nodo que contiene un retorno hasta \verb|SKIP| desempilará el \textit{program pointer} que apunta al nodo \verb|SKIP| y continuará la ``ejecución'' en el nodo apuntado por el próximo \textit{program pointer} en la pila.

Finalmente, se puede seguir una arista desde cualquiera de los nodos de llamada a función hasta \verb|SKIP|.
Esta arista siempre está habilitada (la función \textit{enabled} retorna \verb|True|) y tiene una función \textit{transformer} dado como resultado de \verb|tr_callfunl|, \verb|tr_callfun| o \verb|tr_callfunv| dependiendo de si es una llamada a función que retorne a una celda en memoria, una variable o sin retorno.
Nótese que, también en este caso, al \textit{ejecutar} este comando en el CFG, seguir la arista desde una llamada a función hasta un nodo \verb|SKIP| empilará un nuevo \textit{program pointer} que apunte al nodo con el cuerpo de la función y continuará la ``ejecución'' en el nodo apuntado por el próximo \textit{program pointer} en la pila.

\subsection{Reglas de la semántica de pasos cortos}\label{subsection:rules_small_step}

Finalmente, se introducen las reglas para la semántica de pasos cortos de Chloe.
Se prefiere una semántica de pasos cortos en lugar de una de pasos largos dado que se quiere una semántica mas detallada.
La semántica de pasos largos tiene un gran inconveniente y es que no puede diferenciar entre una ejecución que no termina y una que se queda atascada en una configuración errónea.
Es por ello que se prefiere una semántica mas detallada que permita diferenciar entre no terminación y quedarse atascado en un estado erróneo, dado que permite hablar de estados intermedios durante la evaluación.

Por lo general una configuración en una semántica de pasos cortos es un par que contiene un comando y un estado.
Dado que se trabaja con funciones y se tiene el comando que se esta ejecutando en el marco de pila, la definición de pasos cortos dada en este trabajo es dada sobre estados.
Un paso pequeño y atómico puede ser tomado desde un estado a otro.

Las reglas para la semántica de pasos cortos se encuentran detalladas en la figura~\ref{fig:small_step_rules}.
La notación de infijo para la semántica de pasos cortos se escribe: $s \rightarrow s_{2}$ lo cual significa que se toma un paso corto desde $s$ hasta $s_{2}$.
Se puede dar un paso cuando las siguientes condiciones se cumplen:

\begin{itemize}
  \item{La pila no está vacía}
  \item{Hay una arista en el CFG entre $c_{1}$ y $c_{2}$.}
  \item{El comando en el marco de pila en el tope de la pila en el estado inicial es $c_{1}$.}
  \item{Al aplicar la función \textit{enabled} sobre el estado, esta retorna \verb|True|.}
  \item{Al aplicar la función \textit{transformer} al estado con el comando en marco de pila en el top de la pila actualizdo de $c_{1}$ a $c_{2}$, este retorna un nuevo estado $s_{2}$.}
\end{itemize}

Si todas las condiciones mencionadas anteriormente se cumplen, entonces se puede tomar un paso corto desde el estado $s$ hasta $s_{2}$.

Un paso corto también puede ser tomado al retornar de una función que no retorne valor alguno.
Si el comando en el tope de la pila es \verb|SKIP|, la pila no está vacía y alicar la función \textit{transformer} en el estaod inicial $s$ produce un nuevo estado $s_{2}$, entonces podemos tomar un paso corto desde $s$ hasta $s_{2}$.

El tipo para \verb|small_step| es de \verb|state| a \verb|state option|.
La segunda configuración está encerrada en un tipo opción ya que tomar un paso corto puede resultar en una estado erróneo donde la ejecución se quedará atascada.

Tomar un paso corto puede fallar en cualquiera de los siguientes casos:

\begin{itemize}
  \item{La función \textit{enabled} o la función \textit{transformer} retornan \verb|None| al ser evaluados sobre el estado inicial.
  Esto indica que un estado erróneo fue alcanzado durante la evaluación de alguna de esas dos funciones.
  El estado erróneo se propaga al tomar un paso corto desde el estado $s$ hasta \verb|None| y luego la ejecución se queda atascada allí.}
  \item{Si al aplicar la función \textit{transformer} \verb|tr_return_void| sobre el estado el mismo retorna un valor \verb|None|, el comando en el tope de la pila en el estado inicial es SKIP y la pila no está vacía, entonces también se propaga este estado erróneo \verb|None| al tomar un paso corto desde $s$ hasta \verb|None|.
  Esto indica que hubo un error al retornar de una función sin valor de retorno.}
\end{itemize}

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  inductive
    small_step :: state $\Rightarrow$ state option $\Rightarrow$ bool (infix $\rightarrow$ 55)
  where
    Base: $[\![$ $\neg$ is_empty_stack $s$; $c_{1}$=com_of $s$; cfg $c_{1} (en, tr) $c_{2};
      en $s$ = Some True; tr (upd_com $c_{2}$ $s$) = Some $s_{2}$ $]\!]$ $\Longrightarrow$ s $\rightarrow$ Some $s_{2}$
  | None: $[\![$ $\neg$ is_empty_stack $s$; $c_{1}$=com_of $s$; cfg $c_{1} (en, tr) $c_{2};
      en $s$ = None $\vee$ tr (upd_com $c_{2}$ $s$) = None$]\!]$ $\Longrightarrow$ s $\rightarrow$ None
  | Return_void: $[\![$ $\neg$ is_empty_stack $s$; com_of $s$ = SKIP;
      tr_return_void $s$ = Some $s'$ $]\!]$ $\Longrightarrow$ $s$ $\rightarrow$ Some $s'$
  | Return_void_None: $[\![$ $\neg$ is_empty_stack $s$; com_of $s$ = SKIP;
      tr_return_void $s$ = None $]\!]$ $\Longrightarrow$ $s$ $\rightarrow$ None

  inductive
    small_step' :: (state) option $\Rightarrow$ (state) option $\Rightarrow$ bool (infix $\rightarrow'$  55)
  where
    $s\ \rightarrow\ s'\ \Longrightarrow$ Some $s\ \rightarrow'\ s'$

  abbreviation
    small_steps :: (state) option $\Rightarrow$ (state) option $\Rightarrow$ bool (infix $\rightarrow*$ 55)
  where $s_{0}$ $\rightarrow*$ $s_{f}$ ==  star small_step' $s_{0}$ $s_{f}$
  \end{lstlisting}

  \caption{Small-step rules}
  \label{fig:small_step_rules}
\end{figure}

Se ha definido como tomar un solo paso en la semántica.
Con el fin de tomar mas de un solo paso y definir la ejecución de un programa en la semántica se debe levantar la definición de \verb|small_step| a \verb|state option| tanto en el estado inicial como en el final.

También se define (en la figura~\ref{fig:small_step_rules}) una nueva definición \verb|small_step'| basada en la definición previa para \verb|small_step|.
Esta definición basicamente dice que si un paso corto puede ser tomado desde el estado $s$ hasta $s'$ entonces un paso corto puede ser tomado desde \verb|Some| $s$ hasta $s'$.
Nótese que $s'$ puede ser tanto \verb|None| como \verb|Some| $s_{i}$.
La notación de infijo para esta nueva definición se escribe como \verb|Some| $s \rightarrow' s'$, lo cual significa que se toma un paso corto desde \verb|Some| $s$ hasta $s'$.

De esta manera, se ha levantado la definición de pasos cortos al tipo \verb|state option| y se puede definir la ejecución de un programa como la clausura reflexiva y transitiva de \verb|small_step'|, usando el operador \verb|star| de Isabelle.
La notación de infijo para esto es escrito: $s_{0} \rightarrow* s_{f}$, lo cual significa que se puede ir desde el estado $s_{0}$ hasta $s_{f}$ en cero o mas pasos cortos.

\subsubsection*{Determinísmo}

Para poder ejecutar la semántica dentro del ambiente de Isabelle/HOL, la misma debe ser determinística.
Es por ello que se demuestra que la semántica es determinística.
Con el fin de demostrar esa propiedad, una serie de lemas deben ser definidos y demostrados primero.

Cada vez que se introduce un lema, junto a su número se encontrará un nombre en paréntesis.
Este nombre corresponde al nombre del lema en el código fuente de Isabelle presentados con este trabajo.
En el caso en que el lector esté interesado en la demostración exacta para un lema en particular él o ella puede buscar el lema correspondiente en los archivos y leer la prueba.

Dado que las demostraciones de los siguientes lemas no son el enfoque principal de este trabajo, las mismas se presentan en el apéndice~\ref{ap:determinism}

Este primer lema indica que cada vez que se tiene un comando diferente a \verb|SKIP| hay siempre una arista habilitada (la función \textit{enabled} retorna \verb|True|) que se puede tomar en el CFG o un error ocurre al evaluar la función \textit{enabled}.

\begin{lemma}[cfg\_has\_enabled\_action]
$\newline$
$c$ $\neq$ \verb|SKIP| $\Longrightarrow$ $\exists\ c'\ en\ tr$. \verb|cfg| $c\ (en,tr)\ c'\ \wedge\ (en\ s\ =$ \verb|None| $\vee\ en\ s\ =$ \verb|Some True|$)$
\label{lemma:cfg_enabled_action}
\end{lemma}

\begin{comment}
\begin{proof}
La prueba es por inducción en el comando.
A excepción de dos casos, la prueba es demostrada automáticamente.
Esos dos casos son los comandos \verb|Seq| y \verb|If|.
En el caso de \verb|Seq| se debe hacer una prueba por casos sobre el primer comando de la secuenciación para poder diferenciar los casos cuando es \verb|SKIP| y cuando no.
En ambos casos existe una regla en la defición de CFG que asegura que hay una arista habilitada que se puede tomar y el caso se soluciona automáticamente.

En el caso de \verb|If| se debe hacer una prueba por casos sobre el valor de $\mathtt{en\_pos}\ b\ s$.
Puede fallar y retornar un valor \verb|None|, entonces el caso está resuelto.
Si no falla entonces se debe chequear el valor booleano retornado por la función \verb|en_pos|.
En el caso donde es \verb|True| entonces el caso está resuelto.
El caso difícil es cuando la evaluación de \verb|en_pos| es \verb|False|, semanticamente, esto significa que se debe tomar la rama del else.
Por lo tanto cuando $\mathtt{en\_pos}\ b\ s$ es \verb|False|, $\mathtt{en\_neg}\ b\ s$ siempre se evaluará como \verb|True|, esto significa qe el comando siempre tendrá una arista habilitada que puede seguir, es decir, $\mathtt{en\_neg}\ b\ s$ y la demostración de este caso está completa.
\end{proof}
\end{comment}

A continuación se quiere demostra que mientras la pila no esté vacia, la semántica de pasos cortos siempre puede tomar un paso.
Se utilizará el lema anterior en la prueba para este nuevo lema.
Este lema dice que la semántica puede tomar un paso.

\begin{lemma}[can\_take\_step]
$\newline$
$\neg$ \verb|is_empty_stack| $s$ $\Longrightarrow$ $\exists\ x.\ s\ \rightarrow\ x$
\label{lemma:can_take_step}
\end{lemma}

\begin{comment}
\begin{proof}
De las supociiones sabemos que la pila no está vacia, por lo tanto se puede reescribir el estado de la siguiente manera: $s = ((c, locals, rloc)\#\sigma,\gamma,\mu)$.
Luego se puede hacer una prueba por casos.
Se tiene el caso donde $c\ =\ \mathtt{SKIP}$ y el caso donde $c\\neq\ \mathtt{SKIP}$.

El caso donde $c\ =\ \mathtt{SKIP}$ es el caso en el que se está retornando de la ejecución de una función.
Se tiene que la pila no está vacia, que $c\ =\ \mathtt{SKIP}$ y que $s = ((c, locals, rloc)\#\sigma,\gamma,\mu)$.
Este caso corresponde a las reglas \verb|Return_void| y \verb|Return_void_None| en la definición de \verb|small_step|.
En ambos casos la semántica puede tomar un paso, bien sea a un nuevo estado $s'$ o a \verb|None|.
El caso se resuelve automáticamente por Isabelle al indicar las reglas mencionadas y las suposiciones.

El segundo caso es cuando $c\\neq\ \mathtt{SKIP}$.
Este es el caso donde se ejecuta cualquier otro comando que no sea el retorno de una función.
En este caso se utiliza el lema anterior~\ref{lemma:cfg_enabled_action} y se tiene que $\mathtt{cfg}\ c\ (en,tr)\ c'$ y o la función \textit{enabled} falla ($\mathtt{en}\ s\ = \mathtt{None}$) o está habilidada ($\mathtt{en}|\ s\ = \mathtt{Some True}$).

Esto se demuestra mediante una separación por casos.
En el primer caso se supone $\mathtt{cfg}\ c\ (en,tr)\ c'$ y $\mathtt{en}\ s\ = \mathtt{None}$.
Este es el caso donde la evaluación de la función falla, se sabe que este caso toma un paso corto a None dado por el caso \verb|None| de la definción de \verb|small_step|.
Entonces se ha demostrado que existe un estado tal que $s\ \rightarrow\ \mathtt{None}$.

En el siguiente caso se supone $\mathtt{cfg}\ c\ (en,tr)\ c'$ y $\mathtt{en}\ s\ = \mathtt{Some True}$.
Este es el caso donde hay una arista que está habilitada para ser seguida y aún se deben revisar dos casos mas.
Aplicar la función \textit{transformer} sobre el estado actualizado con el comando ($tr\ (upd\_com\ c'\ s)$) puede fallar o no.
En el caso donde falla (retorna \verb|None|) se puede tomar un paso a \verb|None| y se habrá probado que hay un estado al que $s$ puede tomar un paso corto, es decir \verb|None|.
En el caso donde no falla, retornará $\mathtt{Some}\ s_{2}$.
En este caso se puede tomar un paso a $\mathtt{Some}\ s_{2}$ y se habrá probado que hay un estado al cual $s$ puede tomar un paso corto, es decir $\mathtt{Some}\ s_{2}$.
\end{proof}
\end{comment}

Se definen varios lemas que serán útiles más adelante.

El primer lema establece que el CFG se queda atascado en SKIP:
\begin{lemma}[cfg\_SKIP\_stuck]
$\newline$
$\neg$ \verb|cfg SKIP| $a\ c$
\label{lemma:stuck_at_skip}
\end{lemma}

\begin{comment}
\begin{proof}
La propiedad es demostrada automáticamente.
\end{proof}
\end{comment}


\begin{lemma}[ss\_empty\_stack\_stuck]
$\newline$
\verb|is_empty_stack| $s$ $\Longrightarrow$ $\neg$ $(s\ \rightarrow\ cs')$
\label{lemma:ss_empty_stack_stuck}
\end{lemma}

\begin{comment}
\begin{proof}
La propiedad es demostrada automáticamente.
\end{proof}
\end{comment}


\begin{lemma}[ss'\_SKIP\_stuck]
$\newline$
\verb|is_empty_stack| $s$ $\Longrightarrow$ $\neg$ $(Some s\ \rightarrow\ cs')$
\label{lemma:ss'_empty_stack_stuck}
\end{lemma}

\begin{comment}
\begin{proof}
La propiedad es demostrada automáticamente.
\end{proof}
\end{comment}

Los lemas~\ref{lemma:ss_empty_stack_stuck} y~\ref{lemma:ss'_empty_stack_stuck} definen el estado final en el que la semántica se quedará atascada, la semántica se quedará atascada cuando no existan mas marcos de pila en la pila.


\begin{lemma}[en\_neg\_by\_pos]
$\newline$
\verb|en_neg| $e\ s$ = \verb|map_option (HOL.Not) (en_pos| $e\ s$ \verb|)|
\label{lemma:en_neg_by_pos}
\end{lemma}

\begin{comment}
\begin{proof}
La propiedad es demostrada automáticamente desplegando las definiciones de \verb|en_neg| y \verb|en_pos|.
\end{proof}
\end{comment}

El lema~\ref{lemma:en_neg_by_pos} establece que cada vez que la función \verb|en_neg| tenga un valor (diferente de None) sobre un estado, \verb|en_pos| tendrá el mismo resultado opuesto.
En el caso donde una de las funciones falla, la otra fallará también y retornarán \verb|None|.
Si no fallan, sus resultados serán opuestos, esto es, si una tiene \verb|Some True| como resultado, la otra tendrá \verb|Some False| como resultado.
Este lema será útil al probar que la semántica es determinística.

\begin{lemma}[cfg\_determ]
$\newline$
$\mathtt{cfg}$ $c$ $a1$ $c'$ $\wedge$
$\mathtt{cfg}$ $c$ $a2$ $c''$
$\newline$
$\Longrightarrow$
$a1\ =\ a2$ $\wedge$ $c'\ =\ c''$ $\vee$
$\newline$
$\exists\ b.\ a1\ = (\mathtt{en\_pos}\ b,\ \mathtt{tr\_eval}\ b)\ \wedge\ a2\ = (\mathtt{en\_neg}\ b,\ \mathtt{tr\_eval}\ b)\ \vee$
$\newline$
$\exists\ b.\ a1\ = (\mathtt{en\_neg}\ b,\ \mathtt{tr\_eval}\ b)\ \wedge\ a2\ = (\mathtt{en\_pos}\ b,\ \mathtt{tr\_eval}\ b)$
\label{lemma:cfg_determ}
\end{lemma}

\begin{comment}
\begin{proof}
La demostración es por inducción sobre el comando, con los casos generados automáticamente por Isabelle de las reglas de \verb|cfg|.
Todos los casos se demuestran automáticamente.
\end{proof}
\end{comment}

El lema~\ref{lemma:cfg_determ} establece que CFG es determinístico.
El único caso donde no lo es es en el caso del condicional, para el cual se agrega una alternativa extra en la conclusion.
Puede pasar que se tenga una regla del CFG comanzando en un comando \verb|If| que tiene una arista a $c_{1}$ y también una arista a $c_{2}$.
Esto no es realmente un problema dado que las funciones \textit{enabled} garantizan que cuando esto ocurre, solamente una de las aristas puede ser tomada.


\begin{lemma}[lift\_upd\_com]
$\newline$
$\neg\ \mathtt{is\_empty\_stack}\ s\ \Longrightarrow$
$\newline$
$\mathtt{lift\_transformer\_nr}\ tr\ (\mathtt{upd\_com}\ c\ s)\ =$
$\newline$
$\mathtt{map\_option}\ (\mathtt{upd\_com}\ c)\ (\mathtt{lift\_transformer\_nr}\ tr\ s)$
\label{lemma:lift_upd_com}
\end{lemma}

\begin{comment}
\begin{proof}
Es demostrado automáticamente desplegando la definición de \verb|lift_transformer_nr|.
\end{proof}
\end{comment}

\begin{lemma}[tr\_eval\_upd\_com]
$\newline$
$\neg\ \mathtt{is\_empty\_stack}\ s\ \Longrightarrow$
$\newline$
$\mathtt{tr\_eval}\ e\ (\mathtt{upd\_com}\ c\ s)\ =$
$\newline$
$\mathtt{map\_option}\ (\mathtt{upd\_com}\ c)\ (\mathtt{tr\_eval}\ e\ s)$
\label{lemma:tr_eval_upd_com}
\end{lemma}

\begin{comment}
\begin{proof}
Es demostrado automáticamente desplegando la definición de \verb|tr_eval|.
\end{proof}
\end{comment}

La función \verb|lift_transformer_nr| levanta la definición de una función \textit{transformer}, que opera en el nivel de estados visibles, a estados.
El lema~\ref{lemma:lift_upd_com} establece que no importa en que orden se aplique una función \textit{transformer} sobre un estado y se actualice el comando en el tope de la pila, dado que siempre produce el mismo resultado.
Esto es porque la función que actualiza el comando solo modifica el comando en el tope de la pila y la función \textit{transformer} no puede accesar y modificar esa parte de la pila, ya que solo puede modificar el estado visible.

El lema~\ref{lemma:tr_eval_upd_com} es una versión más específica del lema anterior que establece el mismo hecho específicamente para la función \verb|tr_eval|.


Todos los lemas y definiciones anteriores son definidos con el fin de ser utilizados en la próxima demostración; la semántica de pasos cortos es determinística.
\begin{lemma}[small\_step\_determ]
$\newline$
$s\ \rightarrow\ s'\ \wedge\ s\ \rightarrow\ s''\ \Longrightarrow\ s'\ =\ s''$
\label{lemma:small_step_determ}
\end{lemma}

\begin{comment}
\begin{proof}
La demostración es una prueba por casos sobre la semántica de pasos cortos.
Se obtienen 4 casos, cada uno correspondiente a cada regla en la semántica de pasos cortos.
Los objetivos de prueba generados por las reglas \verb|Return_void| y \verb|Return_void_None| se resuelven automáticamente.
Los objetivos de prueba generados por las reglas \verb|Base| y \verb|None| se resuelven automáticamente luego de agregar los lemas~\ref{lemma:en_neg_by_pos} y ~\ref{lemma:tr_eval_upd_com}.
\end{proof}
\end{comment}

Luego solo queda demostrar que \verb|small_step'| es tambien determinística.

\begin{lemma}[small\_step'\_determ]
$\newline$
$s\ \rightarrow'\ s'\ \wedge\ s\ \rightarrow'\ s''\ \Longrightarrow\ s'\ =\ s''$
\label{lemma:small_step'_determ}
\end{lemma}

\begin{comment}
\begin{proof}
La demostración es una prueba por casos sobre la semántica de pasos cortos.
Se demuestra automáticamente mediante el uso del lema~\ref{lemma:small_step_determ}.
\end{proof}
\end{comment}


\section{Interpretador}\label{section:interpreter}

\subsection{Ejecución de un solo paso}\label{subsection:single_step}

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  datatype cfg_edge = Base $transformer$ $com$
                    | Cond $enabled$ $transformer$ $com$ $com$

  context fixes proc_table :: proc_table begin

    fun cfg_step :: "com $\Rightarrow$ cfg_edge" where
      "cfg_step SKIP = undefined"
    | "cfg_step ($x$ ::= $a$) = Base (tr_assign $x$ $a$) SKIP"
    | "cfg_step ($x$ ::== $a$) = Base (tr_assignl $x$ $a$) SKIP"
    | "cfg_step (SKIP;; $c_{2}$) = Base tr_id $c_{2}$"
    | "cfg_step ($c_{1}$;;$c_{2}$) = (case cfg_step $c_{1}$ of
        Base $tr$ $c$ $\Rightarrow$ Base tr (c;;c2)
      | Cond $en\ tr\ ca\ cb$ $\Rightarrow$ Cond $en\ tr\ \mathtt{(}ca\mathtt{;;}c2\mathtt{)}\ \mathtt{(}cb\mathtt{;;}c2\mathtt{)}$
       )"
    | "cfg_step (IF $b$ THEN $c_{1}$ ELSE $c_{2}$) = Cond (en_pos $b$) (tr_eval $b$) $c_{1}$ $c_{2}$"
    | "cfg_step (WHILE $b$ DO $c$) =
        Base tr_id (IF $b$ THEN $c$;; WHILE $b$ DO $c$ ELSE SKIP)"
    | "cfg_step (FREE $x$) = Base (tr_free $x$) SKIP"
    | "cfg_step (Return $a$) = Base (tr_return $a$) SKIP"
    | "cfg_step Returnv = Base (tr_return_void) SKIP"
    | "cfg_step (Callfunl $e$ $f$ params) =
        Base (tr_callfunl proc_table $e$ $f$ params) SKIP"
    | "cfg_step (Callfun $x$ $f$ params) =
        Base (tr_callfun proc_table $x$ $f$ params) SKIP"
    | "cfg_step (Callfunv $f$ params) =
        Base (tr_callfunv proc_table $f$ params) SKIP"

  end
  \end{lstlisting}

  \caption{Aristas de un solo paso}
  \label{fig:single_step_edges}
\end{figure}

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  definition fstep :: proc_table $\Rightarrow$ state $\Rightarrow$ state option where
    fstep proc_table $s$ $\equiv$
      if com_of $s$ = SKIP then
        tr_return_void $s$
      else
        case cfg_step proc_table (com_of $s$) of
            Base $tr\ c'$ $\Rightarrow$ $tr$ (upd_com $c'\ s$)
          | Cond $en\ tr\ c1\ c2$ $\Rightarrow$ do {
              $b$ $\leftarrow$ en $s$;
              if $b$ then
                tr (upd_com $c1\ s$)
              else  
                tr (upd_com $c2\ s$)
            }
  \end{lstlisting}

  \caption{Definición de fstep}
  \label{fig:fstep_def}
\end{figure}

Existen dos tipos de pasos que se pueden tomar en el CFG.
Se crea un nuevo tipo de datos par representarlos.


Un paso $Base$ tiene una función \textit{transformer} y siempre está habilitada para seguir hasta un nuevo comando y un paso $Cond$ que, además de la función \textit{transformer}, también tiene una función \textit{enabled} y dos comandos.
Esta función \textit{enabled} indica si se debe tomar un paso al primer o al segundo comando.
También se define una función \verb|cfg_step| que dada el comando de inicio retorna que tipo de paso sigue en el CFG.

La función \verb|fstep|, definida en la figura~\ref{fig:fstep_def}, indica como se toma un solo paso el la ejecución de la semántica.
La ejecución de un paso en la semántica va desde un estado inicial a un nuevo estado que puede ser erróneo (\verb|None|) o uno válido (\verb|Some| $s$).
Para ejecutar un comando \verb|SKIP| se llama a \verb|tr_return_void|.
En cualquier otro comando se verifica que tipo de paso se debe tomar utilizando la función \verb|cfg_step| y, basado en esto, se decide que hacer.
Si es un paso \verb|Base| se llama a la función \textit{transformer} sobre el estado con el comando actualizado.
Si es un paso \verb|Cond| se evalúa la condición y se llama a la función transformer sobre el estado con el comando actualizado.

\subsubsection*{Equivalencia entre semántica de pasos cortos y ejecución de un solo paso}\label{subsubsection:equality_ss_ss}

Ahora se debe demostrar que le ejecución de un solo paso es semánticamente equivalente a tomar un paso en la semántica de pasos cortos.
Esto significa probar que $\neg\ \mathtt{is\_empty\_stack}\ \Longrightarrow\ s\ \rightarrow\ s'\ \longleftrightarrow\ \mathtt{fstep}\ s\ =\ s'$~\footnote{fstep tiene un parámetro extra, es decir la tabla de procedimientos, que no se escribirá acá para simplificar la lectura.}.
Se demuestran ambas direciones de la equivalencia por separado: para cada paso tomado en la semántica de pasos cortos hay un paso equivalente que puede ser tomado en la ejecución por \verb|fstep| que llevará al mismo estado final y viceversa.


Se comienza demostrando que cualquier paso tomado en la semántica de pasos cortos puede ser simulado a través de un paso tomado con \verb|fstep|.

\begin{lemma}[fstep1]
$\newline$
$s\ \rightarrow\ s'\ \Longrightarrow\ \mathtt{fstep}\ s\ =\ s'$
\label{lemma:fstep1}
\end{lemma}

\begin{comment}
\begin{proof}
La demostración es por inducción sobre la semántica de pasos cortos.
\end{proof}
\end{comment}

Luego se considera la dirección opuesta:

\begin{lemma}[fstep2]
$\newline$
$\neg\ \mathtt{is\_empty\_stack}\ s\ \Longrightarrow\ s\ \rightarrow\ (\mathtt{fstep}\ s)$
\label{lemma:fstep2}
\end{lemma}

\begin{comment}
\begin{proof}
La demostración se hace automáticamente mediante una prueba por casos sobre el resultado de ``\verb|tr_return_void| $s$'' y utilizando los lemas~\ref{lemma:can_take_step} y~\ref{lemma:fstep1}.
\end{proof}
\end{comment}

Ambas direcciones juntas (lema~\ref{lemma:fstep1} y lema~\ref{lemma:fstep2}) permiten demostrar la equivalencia planteada al inicio:

\begin{lemma}[ss\_fstep\_equiv]
$\newline$
$\neg\ \mathtt{is\_empty\_stack}\ \Longrightarrow\ s\ \rightarrow\ s'\ \longleftrightarrow\ \mathtt{fstep}\ s\ =\ s'$
\label{lemma:ss_fstep_equiv}
\end{lemma}


\subsection{Ejecución e interpretación}\label{subsection:exec_interp}

Al igual que en la sección anterior las demostraciones para los lemas de esta sección se encuentran en el apéndice~\ref{ap:interpreter}.

Con el fin de ejecutar un programa se define un interpretador.

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  fun is_term :: "state option $\Rightarrow$ bool" where
    "is_term (Some $s$) = is_empty_stack $s$"
  | "is_term None = True"

  definition interp :: "proc_table $\Rightarrow$ state $\Rightarrow$ state option" where
    "interp proc_table $cs$ $\equiv$ (while
      (HOL.Not $\circ$ is_term)
      ($\lambda$Some $cs$ $\Rightarrow$ fstep proc_table $cs$)
      (Some $cs$))"
  \end{lstlisting}

  \caption{Definición de un interpretador para Chloe}
  \label{fig:interpreter_def}
\end{figure}

La definición para tal interpretador se encuentra en la figura~\ref{fig:interpreter_def}.
Primero se define el criterio para considerar un estado como final.
Un estado será considerado como final cuando su pila de ejecución esté vacia o cuando sea \verb|None|.

El interpretador para la semántica funciona de la siguiente manera: mientras no se alcance un estado final se ejecuta \verb|fstep|.

Se presenta un lema que establece que si un estado es final, entonces es el resultado de la interpretación.

\begin{lemma}[interp\_term]
$\newline$
$\mathtt{is\_term}\ \mathtt{(Some}\ cs\mathtt{)}\ \Longrightarrow\ \mathtt{interp}\ \mathtt{proc\_table}\ cs\ =\ \mathtt{Some}\ cs$
\label{lemma:interp_term}
\end{lemma}

Para poder demostrar esto necesitamos un lema que expanda la definición del ciclo en la definición de nuestro interpretador:

\begin{lemma}[interp\_unfold]
$\newline$
$\mathtt{interp}\ \mathtt{proc\_table}\ cs = ($
$\newline$
$\mathtt{if}\ \mathtt{is\_term}\ (\mathtt{Some}\ cs)\ \mathtt{then}\ \mathtt{Some}\ cs$
$\newline$
$\mathtt{else}\ \mathtt{do\{}\ cs \leftarrow\ \mathtt{fstep}\ \mathtt{proc\_table}\ cs\mathtt{;}\ \mathtt{interp}\ \mathtt{proc\_table}\ cs$
$\mathtt{\}})$
\label{lemma:interp_unfold}
\end{lemma}

\begin{comment}
\begin{proof}
La demostración es hecha automáticamente.
\end{proof}
\end{comment}

Con el lema~\ref{lemma:interp_unfold}, la demostración del lema~\ref{lemma:interp_term} se hace automáticamente.

Solamente programas válidos pueden ser ejecutados.
En la figura~\ref{fig:execute_def} se encuentra la definición de la función que ejecuta un programa.
Para ejecutar un programa se debe asegurar que el mismo es válido utilizando el criterio definido en \verb|valid_program| y luego se interpreta el estado inicial del programa p.

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  definition execute :: "program $\Rightarrow$ state option" where
    "execute $p$ $\equiv$ do {
      assert (valid_program $p$);
      interp (proc_table_of $p$) (initial_state $p$)
    }"
  \end{lstlisting}

  \caption{Definición de un interpretador para Chloe}
  \label{fig:execute_def}
\end{figure}


\subsection{Correctitud}\label{subsection:correctness}

Por último, se debe demostrar que el interpretador es correcto.
En la figura~\ref{fig:execution_definitions} se encuentran dos definiciones con respecto a la ejecución.
La primera establece que una ejecución de un estado $cs$ produce (\verb|yields|) $cs'$ si se pueden tomar pasos cortos desde $cs$ hasta $cs'$ y $cs'$ es un estado final.
En segundo lugar, se dice que la ejecución de un estado \textit{termina} si existe algún estado $cs'$ tal que sea producido por la ejecución del estado $cs$.

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  definition "yields $\equiv$ $lambda\ cs\ cs'$. Some $cs$ $\rightarrow*$ $cs'$ $/wedge$ is_term cs'"

  definition "terminates $\equiv$ $lambda\ cs$. $\exists\ cs'$. yields $cs\ cs'$"
  \end{lstlisting}

  \caption{Definiciones sobre ejecución de programas}
  \label{fig:execution_definitions}
\end{figure}

Antes de demostrar el lema de correctitud para el interpretador, se debe demostrar que la semátnica de pasos cortos preserva un estado erróneo \verb|None| si tal es alcanzado por el camino de pasos tomados.
Tras una ejecución errónea, la misma se queda atascada en un estado \verb|None|.

\begin{lemma}[None\_star\_preserved]
$\newline$
$\mathtt{None}\ \rightarrow*\ z\ \longleftrightarrow\ z\ =\ \mathtt{None}$
\label{lemma:none_star_preserved}
\end{lemma}

\begin{comment}
\begin{proof}
La demostración es por inducción sobre la clausura reflexivo transitiva (\verb|star|).
Los objetivos se resuelven automáticamente.
\end{proof}
\end{comment}

Finalmente se tiene la propiedad de correctitud para el interpretador.
El teorema~\ref{theorem:interp_correct} establece qeu si la ejecución de $cs$ termina, entonces esa ejecución produce $cs'$ si y solo si $cs'$ es el resultado que se obtiene de ejecutar el programa en el interpretador.

\begin{theorem}[interp\_correct]
$\newline$
$\mathtt{terminates}\ cs\ \Longrightarrow\ (\mathtt{yields}\ cs\ cs')\ \longleftrightarrow\ (cs'\ =\ \mathtt{interp}\ \mathtt{proc\_table}\ cs)$
\label{theorem:interp_correct}
\end{theorem}

\begin{comment}
\begin{proof}
La demostración se hace suponiendo el antecedente y demostrando cada dirección de la igualdad por separado.
\end{proof}
\end{comment}
