\chapter{Sintaxis y Semántica}\label{chapter:semantics}
\lhead{Capítulo 3. \emph{Sintaxis y Semántica}}

El lenguaje imperativo de este trabajo se llama Chloe y representa un subconjunto del lenguaje C.
Un programa es una secuencia de una o más instrucciones (o comandos) escritos para llevar a cabo una tarea en una computadora.
Cada una de estas instrucciones representa una instrucción que la máquina ejecutará.
Estas instrucciones pueden contener componentes internos llamados expresiones.
Una expresión es un termino que consta de valores, constantes, variables, operadores, etc. que puede ser evaluado en el contexto de un estado del programa para obtener un valor que puede ser luego utilizado en una instrucción.
En las secciones siguientes se procederá a describir la sintaxis y la semántica de los programas en Chloe con más detalle.


\section{Expresiones}\label{section:expressions}

\subsection{Sintaxis}\label{subsection:syntax_expressions}

En esta sección se describe la \textbf{sintaxis abstracta} de las expressiones en el lenguaje Chloe.

\begin{figure}
  \begin{lstlisting}[frame=single]
  type_synonym vname = string

  datatype exp = Const int
               | Null
               | V      vname
               | Plus  exp exp
               | Subt  exp exp
               | Minus exp
               | Div   exp exp
               | Mod   exp exp
               | Mult  exp exp
               | Less  exp exp
               | Not   exp
               | And   exp exp
               | Or    exp exp
               | Eq    exp exp
               | New   exp
               | Deref exp
               | Ref   lexp
               | Index exp exp
  and
  datatype lexp = Deref exp
                | Indexl exp exp
  \end{lstlisting}

  \caption{Chloe expressions}
  \label{fig:chloe_expressions}
\end{figure}

En la figura~\ref{fig:chloe_expressions} se encuentra el tipo de datos creado en isabelle para las expresiones, donde \verb|int| es el tipo predefinido para los enteros y \verb|vname| significa nombre de la variable.

Se definen dos nuevos tipos de datos, uno para las expresiones y otro para las expresiones del lado izquierdo.
Es importante diferenciar entre estos dos tipos en el caso en que se trabaja con expresiones que contienen apuntadores.
Por ejemplo, suponiendo que se tienen las siguientes instrucciones en C:

\begin{lstlisting}[mathescape=true, frame=single]
foo = *bar;
*baz = 1;
\end{lstlisting}

donde \verb|foo| y \verb|bar| son variables, \verb|1| es un valor constante, ``\verb|=|'' indica una instrucción de asignación y ``\verb|*|'' corresponde al operador de desreferencia.

En la primera expresión \verb|*bar| se encuentra del lado derecho de la asignación, en este caso se quiere que \verb|*bar| produzca un valor que pueda ser luego asignado a \verb|foo|.
Por otra parte, en la segunda expresión \verb|*baz| se encuentra del lado izquierdo de la asignación, en este caso se quiere que \verb|*baz| produzca una dirección a la cual se le pueda asignar el valor \verb|1|.

Esto también ocurre con el acceso a arreglos.
Para modelar correctamente la semántica de las expresiones en Chloe, es necesario contar con esta distinción entre expresiones del lado izquierdo (\textit{l-values}) y expresioness del lado derecho (\textit{r-values}).
En las siguientes secciones al referirse a expresiones del lado derecho o \textit{r-values} se utilizará simplemente el nombre expresiones y se utilizará expresión del LHS (por sus siglas en ingles \textit{left-hand-side}) en lugar de \textit{l-values} o expresiones del lado izquierdo al referirse a dichas expresiones.
\begin{comment}
FIXME mosca! esto está mal traducido!
\end{comment}

Chloe soporta expresiones constantes, apuntadores a \textit{null} y variables, así como las siguientes operaciones sobre expresiones: suma, resta, menos unario, división, módulo, multiplicación, menor que, negación, conjunción, disyunción e igualdad.
También cuenta con una expresión \verb|New| que corresponde a una llamada a \verb|malloc| en C.
Tiene operadores de desreferencia, referencia y acceso a arreglos.
En C, estos son los operadores \verb|*|, \verb|&| y \verb|[]|, respectivamente.
Finalmente, como expresiones del LHS se tienen las operaciones de desreferencia y accesso a arreglos.
\begin{comment}
FIXME mosca! esto está mal traducido!
\end{comment}

\subsubsection*{Tipos}

En el lenguaje Chloe se tienen dos tipos; enteros y direcciones.
Se diferencia entre los valores de tipo entero y las direcciones con el fin de definir correctamente la semántica.
A continuación, se presentan los detalles de los dos tipos en el lenguaje Chloe.

\paragraph*{Enteros}

Se establecen los siguientes sinónimos entre tipos en Isabelle:

\begin{lstlisting}[frame=single]
type_synonym int_width = 64
type_synonym int_val = int_width word
\end{lstlisting}


El termino \verb|int_width| se refiere a la precisión del valor entero.
En el caso de este trabajo se supone un valor de 64 ya que se trabaja con una arquitectura de 64 bits.
Este parametro le indica a la semántica que debe suponer que se trabaja con una arquitectura de 64 bits donde los límites inferiores y superiores para un entero se definen en la figura~\ref{fig:int_bounds}.

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  abbreviation INT_MIN :: int where INT_MIN $\equiv$ - (2^(int_width - 1))
  abbreviation INT_MAX :: int where INT_MAX $\equiv$  ((2^(int_width - 1)) - 1)
  \end{lstlisting}

  \caption{Integer lower and upper bounds}
  \label{fig:int_bounds}
\end{figure}

Cuando se trabaja con una arquitectura diferente, este parametro puede ser cambiado con el fin de cumplir con los requerimientos de la arquitectura.

Tambien, los enteros se definen como palabras de longitud \verb|int_width| (en este caso \verb|64|).
Debido a que no se utiliza el tipo predefinido \verb|int| en Isabelle, para poder trabajar con palabras y soportar la generación de código para las mismas se utiliza la entrada \textit{Native Word} en el \textit{Archive of Formal Proofs}~\cite{Native_Word-AFP}.

De ahora en adelante se referirá a las palabras de longitud 64 que se utilizan para representar a los enteros en Chloe como simplemente enteros.
Es importante notar que, a menos de que sea explícitamente mencionado en el texto, por simplicidad se utilizará la palabra `entero' para referirse a las palabras de longitud 64 en lugar del tipo predefinido \verb|int| en Isabelle.

\paragraph*{Direcciones}

Se define el siguiente tipo de datos en Isabelle para representar direcciones:

\begin{lstlisting}[frame=single, mathescape=true]
datatype addr = nat $\times$ int
\end{lstlisting}

\begin{comment}
FIXME block_id, offset
\end{comment}
Una dirección es entonces un par compuesto por un número natural y un entero (el cual es de tipo \verb|int| predefinido en Isabelle), estos representan un par \verb|(block_id, offset)|.
En secciones futuras se procederá a explicar el diseño de la memoria.

\subsubsection*{Valores}

Los valores para una expresión se definen de la siguiente forma:

\begin{lstlisting}[frame=single, mathescape=true]
datatype val = NullVal | I $int\_val$ | A $addr$
\end{lstlisting}

donde \verb|NullVal| corresponde a un apuntador a \textit{null}, \verb|I| $int\_val$ corresponde a un valor entero y \verb|A| $addr$ corresponde al valor de una dirección.
Al evaluar una expresión se puede obtener cualquiera de estos tres valores.

\subsubsection*{Memoria}

Se modela la memoria dinámica de la siguiente manera:

\begin{lstlisting}[frame=single, mathescape=true]
type_synonym mem = val option list option list
\end{lstlisting}

La memoria se encuentra representada como una lista de bloques asignados y cada uno de estos bloques consta de una lista de celdas con los valores en memoria.
Por cada bloque hay dos posibilidades: un bloque asignado o un bloque no asignado, esto es modelado por el uso del tipo \verb|option|, donde \verb|Some| $l$ (donde $l$ es de tipo \verb|val option list|) denota un bloque asignado y \verb|None| uno sin asignar.
Cada bloque se compone de una lista de celdas que contienen los valores en memoria.
Cada celda puede tener diferentes valores dependiendo de si se encuentra sin inicializar o si posee un valor.
Una celda sin sin inicializar en memoria está representada por el valor \verb|None|.
Mientras que una celda que posee un valor está representada por el valor \verb|Some| $v$ (donde $v$ es de tipo \verb|val|).
Este modelo de memoria está inspirado en el trabajo de Blazy y Leroy~\cite{leroy-blazy-memory-model}, es un modelo simplificado que fue ajustado para satisfacer las necesidades de este trabajo.

Existen cuatro operaciones principales para la gestión de memoria, estas son \verb|new_block|, \verb|free|, \verb|load| y \verb|store| y se encuentran especificadas en la figura~\ref{fig:mem_operations}.
Cada una de estas operaciones puede fallar, por lo que su tipo de retorno es $\tau\ \verb|option|$.
Los valores de ese tipo son \verb|None| cuando la operación falla y $\verb|Some|(v)$ cuando es exitosa (donde $v$ es de tipo $\tau$).

Las funcionalidades de las operaciones de gestión de memoria se describen a continuación:

\begin{itemize}
  \item{\verb|new_block| es la función que se encarga de asignar un nuevo bloque de memoria dinámica de un tamaño determinado.
    Esta función fallará en el caso donde el tamaño dado sea menor o oigual a cero, también puede fallar si un valor de un tipo diferente a entero es dado.
    Al ser ejecutada exitosamente, la función retorna la dirección de inicio del nuevo bloque junto con la memoria modificada.}
  \item{\verb|free| es la función que se encarga de liberar un bloque de memoria dinámica.
    Esta función fallará en el caso donde la dirección dada no sea válida en memoria.
    Al ser ejecutada exitosamente, la función retorna un nuevo estado que incluye la memoria actualizada.}
  \item{\verb|load| es la función que, dada una dirección, retorna el valor almacenado en la celda de memoria denotada por la dirección dada.
    Esta función fallará en el caso donde la dirección dada no sea válida en memoria.
    Al ser ejecutada exitosamente, la función retornará el valor almacenado en memoria.}
  \item{\verb|store| es la función que, dada una dirección y un valor, almacena dicho valor en la celda de memoria denotada por la dirección dada.
    Esta función fallará en el caso donde la dirección dada no sea válida en memoria.
    Al ser ejecutada exitosamente, la función retorna un nuevo estado que incluye la memoria actualizada.}
\end{itemize}

\begin{figure}
  \begin{lstlisting}[mathescape=true, frame=single]
  new_block :: val $\Rightarrow$ mem $\Rightarrow$ (val $\times$ mem) option
  free      :: addr $\Rightarrow$ val  $\Rightarrow$ visible_state $\Rightarrow$ visible_state option
  load      :: addr $\Rightarrow$ mem $\Rightarrow$ val option
  store     :: addr $\Rightarrow$ val  $\Rightarrow$ visible_state $\Rightarrow$ visible_state option
  \end{lstlisting}

  \caption{Memory Management operations}
  \label{fig:mem_operations}
\end{figure}

Es importante tener en cuenta que las únicas razones por las que la asignación de memoria dinámica puede fallar en la semántica son aquellas descritas anteriormente.
Debido a que se supone que la memoria es ilimitada, no existirá un caso donde una llamada a \verb|new| falle debido a falta de memoria.

Sin embargo, como los recursos de una máquina son limitados, no se puede utilizar una cantidad ilimitada de memoria.
Aquí es donde se consigue una discrepancia con lo descrito por el estándar de C.
Cuando se realiza una llamada a malloc en un programa en C, existe una posibilidad de que la llamada retorne \verb|NULL|.
En tal caso esta semántica y la descrita por el estándar de C actúan de manera diferente.

Una opción para poder modelar una función de asignación de memoria que presente este tipo de comportamiento, es decidir de manera no determinística cuando esta función puede retornar \verb|null|.
El problema con esta opción es que complicaría el proceso de demostración de propiedades de un programa ya que cualquier llamada a la función de asignación de memoria dinámica podría fallar.
Otra opción sería suponer que se cuenta con una cantidad fija de memoria está disponible.
Sin embargo, modelar este tipo de función no es una tarea trivial y permanece fuera del alcance de este trabajo.

Por lo tanto, en este trabajo se supone que se cuenta con una cantidad ilimitada de memoria y luego, cuando el proceso de traducción se lleva a cabo, se envuelve la función \verb|malloc| de C en una función definida por el usuario que verifica si la llamada a \verb|malloc| fue exitosa o no.
Lo que se puede garantizar sobre un programa generado es que o bien se generará y tanto la ejecución del mismo en el ambiente de Isabelle como la ejecución en la máquina producirán estados finales que son equivalentes o el programa abortará si un error por falta de memoria es encontrado.


\subsection{Semántica}\label{subsection:semantics_expressions}

La semántica de una expresión es su valor y el efecto que evaluar la misma tiene sobre el estado del programa.
Para expresiones tales como $21 + 21$, la evaluación de la misma es trivial ($42$).
Por otra parte, cuando se tienen expresiones con variables, tales como $foo + 42$, entonces se depende del valor de la variable.
Por lo tanto se deben conocer el valor de una variable al momento de ejecución.
Estos valores se almacenan en el estado del programa.

El estado de un programa es realmente un poco mas complicado que lo que se presenta a continuación.
Aunque la sección~\ref{section:states} se dedica exclusivamente a discutir los estados, se procede a describir en esta sección las partes el estado que son necesarias para discutir la semántica de las expresiones en Chloe.

\paragraph*{Valuaciones}\label{paragraph:valuation}

Se define el tipo para una valuación de la siguiente manera:

\begin{lstlisting}[frame=single, mathescape=true]
type_synonym valuation = vname $\Rightarrow$ val option option
\end{lstlisting}

Una valuación es una función que ``mapea'' un nombre de una variable a un valor.
El tipo de retorno es \verb|val option option|, lo que modela los siguientes estados para el valor de una variable: no definida, no inicializada y posee un valor.
Por lo tanto, dado un nombre de una variable, esta función puede producir uno de los siguientes resultados:

\begin{itemize}
  \item{\verb|None|, que representa una variable que no está definida.}
  \item{\verb|Some None|, que representa una variable que está definida pero no ha sido inicializada.}
  \item{\verb|Some| $v$, que representa una variable que está definida e inicializada y contiene el valor v.}
\end{itemize}

\paragraph*{Estados visibles}\label{paragraph:visible_state}

Cuando se ejecuta un comando, el mismo solo puede \textit{ver} cierta parte del estado.
La parte de un estado que un comando puede ver es aquella que contiene las variables que son locales a la función que se está ejecutando, las variables globales y la memoria.
Esta parte del estado es precisamente lo que se llama \textit{estado visible}.
Se puede definir un estado visible como la parte de un estado que un comando puede ver y modificar.
El tipo definido para ellos es el siguiente:

\begin{lstlisting}[frame=single, mathescape=true]
type_synonym visible_state = valuation $\times$ valuation $\times$ mem
\end{lstlisting}

Un estado visible es una tupla que contiene una función de valuación para las variables locales, una función de valuación para las variables globales y la memoria dinámica del programa.

\paragraph*{}
Ahora se puede introducir la semántica para las expresiones en Chloe.
Como fue expresado antes, la semántica de una expresión es su valor y el efecto que tiene la misma sobre el estado de un programa, por lo tanto se definen dos funciónes de evaluación, una que calcula el valor de una expresión y una que calcula el valro de una expresión del LHS.
Estas funciones se definen de la siguiente manera:

\begin{lstlisting}[frame=single, mathescape=true]
eval   :: exp $\Rightarrow$ visible_state $\Rightarrow$ (val $\times$ visible_state) option
eval_l :: lexp $\Rightarrow$ visible_state $\Rightarrow$ (addr $\times$ visible_state) option
\end{lstlisting}

donde \verb|eval|, dada una expresión y un estado visible, retornará el valor de esta expresión y el estado visible resultante de evaluar dicha expresión.
La función \verb|eval_l|, dada una expresión del LHS y un estado visible, retornará el valor de esta expresión (el cual debe ser una dirección) y el estado resultante luego de evaluar dicha expresión.
Es importante tener en cuenta que el tipo de retorno de las funciones de evaluación es el tipo \verb|option|.
Esto es debido a que estas funciones pueden fallar.
Un fallo puede ocurrir en cualquier momento al evaluar una expresión y si un fallo es encontrado entonces el mismo se propaga hasta que toda la evaluación de la expresión devuelva un valor \verb|None| que indica un error en la evaluación.

La evaluación de una expresión puede fallar por diversas razones que incluyen, pero no están limitadas a, variables no definidas, operandos ilegales en operaciones, acceso a partes inválidas de memoria y ``overflow''.
Por lo tanto, si hay un error temprano en la semántica de evaluación de expresiones, será detectado y propagado como un valor \verb|None| que indica un estado erróneo.

Las funciones \verb|eval| y \verb|eval_l| dependen de otras funciones definidas con el find e calcular correctamente los valores de las expresiones.
La definición de todas las funciones auxiliares para \verb|eval| y \verb|eval_l| se encuentra en la figura~\ref{fig:aux_fun_eval}.
A excepción de \verb|div_towards_zero| y \verb|mod_towards_zero|, cada una de estas operaciones pueden fallar, por lo que su tipo de retorno es $\tau$ \verb|option|.
Los valores de este tipo son o \verb|None| cuando la operación falla o $\verb|Some|(v)$ donde $v$ es de tipo $\tau$.

\begin{figure}
  \begin{lstlisting}[mathescape=true, frame=single]
  detect_overflow  :: int $\Rightarrow$ val option
  read_var         :: vname $\Rightarrow$ visible_state $\Rightarrow$ val option
  plus_val         :: val $\Rightarrow$ val $\Rightarrow$ val option
  subst_val        :: val $\Rightarrow$ val $\Rightarrow$ val option
  minus_val        :: val $\Rightarrow$ val option
  div_towards_zero :: int $\Rightarrow$ int $\Rightarrow$ int
  div_val          :: val $\Rightarrow$ val $\Rightarrow$ val option
  mod_towards_zero :: int $\Rightarrow$ int $\Rightarrow$ int
  mod_val          :: val $\Rightarrow$ val $\Rightarrow$ val option
  mult_val         :: val $\Rightarrow$ val $\Rightarrow$ val option
  less_val         :: val $\Rightarrow$ val $\Rightarrow$ val option
  not_val          :: val $\Rightarrow$ val option
  to_bool          :: val $\Rightarrow$ bool option
  eq_val           :: val $\Rightarrow$ val $\Rightarrow$ val option
  new_block        :: val $\Rightarrow$ mem $\Rightarrow$ (val $\times$ mem) option
  load             :: addr $\Rightarrow$ mem $\Rightarrow$ val option
  \end{lstlisting}

  \caption{Funciones auxiliares para eval y eval\_l}
  \label{fig:aux_fun_eval}
\end{figure}

Las funcionalidades de las funciones auxiliares son las siguientes:

\begin{itemize}
\item{La función \verb|detect_overflow| detecta el ``overflow'' en enteros.
Toma como parametro un valor del tipo entero predefinido por Isabelle y chequea si existe ``overflow'' con los límites mostrados en la figura~\ref{fig:int_bounds}.
Esta función fallará cuando se detecte ``overflow''.
Al ser ejecutada exitosamente, la función retorna el valor correspondiente al entero dado como parámetro.}

\item{La función \verb|read_var| calcula el valor de una variable.
Esta función falla cuando el nombre de la variable dado como parámetro corresponde a una variable no definida.
Al ser ejecutada exitosamente, la función retorna el valor de la variable.
Con el fin de calcular el valor de dicha variable, esta función chequea la valuación de las variables locales en el estado visible y retorna el valor de la variable si se encuentra definida allí.
En el caso en el que la variable no se encuentre definida en el alcance local, la función procederá a chequear el alcance global y retornará el valor de la variable.}

\item{La función \verb|plus_val| calcula el valor de la suma entre dos valores.
Esta función falla cuando se detecta ``overflow'' o cuando operandos distintos a dos enteros o una dirección y un entero (en ese orden específico) son dados como parametros a la función.
Al ser ejecutada exitosamente con dos valores de tipo entero como parámetros, la función retorna un valor entero correspondiente a la suma de los operandos.
Al ser ejecutada exitosamente con una dirección y un entero como parámetros, la función retorna una dirección correspondiente a la suma del ``offset'' entero al valor original de la dirección.}

\item{La función \verb|subst_val| calcula el valor de una sustracción entre dos valores.
Esta función falla cuando se detecta ``overflow'' o cuando operandos distintos a dos enteros o una dirección y un entero (en ese orden específico) son dados como parametros a la función.
Al ser ejecutada exitosamente con dos valores de tipo entero como parámetros, la función retorna un valor correspondiente a la resta de los operandos.
Al ser ejecutada exitosamente con una dirección y un entero como parámetros, la función retorna una dirección correspondiente a la resta del ``offset'' entero al valor original de la dirección.}

\item{La función \verb|minus_val| calcula el valor de la operación de menos unario sobre un valor.
Esta función falla cuando se detecta ``overflow'' o cuando un operando distinto a un entero es dado.
Al ser ejecutada exitosamente, la función retorna un valor entero correspondiente al resultado de negar el valor dado como parámetro.}

\item{La función \verb|div_towards_zero| realiza la división entera con truncamiento hacia cero.}

\item{La función \verb|div_val| calcula el valor de la división entre dos valores.
La función falla cuando se detecta ``overflow'' o una división por cero o cuando operandos distintos a dos enteros son dados como parámetros a la función.
Al ser ejecutada exitosamente, la función retorna un valor entero correspondiente al resultado de la división entera entre los dos operandos.}

\item{La función \verb|mod_towards_zero| realiza la operación de módulo con truncamiento hacia cero.}

\item{La función \verb|mod_val| calcula el valor de la operación módulo entre dos valores.
La función falla cuando se detecta ``overflow'' o una división por cero o cuando operandos distintos a dos enteros son dados como parámetros a la función.
Al ser ejecutada exitosamente, la función retorna un valor entero correspondiente al resultado de la operación de módulo entre los dos operandos.}

\item{La función \verb|mult_val| calcula el valor de la multipliación entre dos valores.
La función falla cuando se detecta ``overflow'' o cuando operandos distintos a dos enteros son dados como parametros a la función. 
Al ser ejecutada exitosamente, la función retorna un valor entero correspondiente a la multiplicación de los operandos de la función.}

\item{La función \verb|less_val| calcula el valor resultante de realizar la operación menor que entre dos valores.
La función falla cuando operandos distintos a dos enteros son dados como parámetros a la función.
Al ser ejecutada exitosamente, la función retorna un valor entero \verb|I| $1$ cuando el primer operando es menor que el segundo y un valor entero \verb|I| $0$ de lo contrario.}

\item{La función \verb|not_val| calcula el valor resultante de realizar la negación lógica sobre un valor.
La función falla cuando un operando distinto a un entero es dado como parámetro.
Al ser ejecutada exitosamente, la función retorna un valor entero \verb|I| $1$ cuando el operando dado es un entero de valor \verb|I| $0$ y retorna un valor entero \verb|I| $0$ cuando el operando dado es un entero de valor diferente de \verb|I| $0$.}

\item{La función \verb|to_bool| retorna un valor de tipo booleano predefinido en Isabelle dado un operando.
La función se utiliza para calcular evaluación de corto circuito para las operaciones \verb|And| y \verb|Or|.
La función falla cuando un operando distinto a un entero es dado como parámetro.
Al ser ejecutada exitosamente, la función retorna \verb|False| cuando el parámetro dado tiene un valor igual a \verb|I| $0$ y retorna \verb|True| de lo contrario.}

\item{La función \verb|eq_val| calcula el valor resultante de relizar la comparación de igualdad entre dos valores.
La función falla cuando operandos diferentes a dos enteros o dos direcciones son dados como parámetros.
Al ser ejecutada exitosamente con dos valores enteros como parámetros, la función retorna un valor entero \verb|I| $1$ si ambos operandos son iguales y un valor entero \verb|I| $0$ de lo contrario.
Al ser ejecutada exitosamente con dos direcciones como parámetros, la función retorna un valor entero \verb|I| $1$ si ambas direcciones son iguales y un valor entero \verb|I| $0$ de lo contrario.
Dos direcciones son consideradas como iguales cuando ambos componentes de la tupla son iguales.}

\item{Las funciones \verb|new_block| y \verb|load| son aquellas explicadas anteriormente en la sección~\ref{subsection:syntax_expressions} que se encargan de asignar un nuevo bloque de memoria y cargar un valor desde memoria, respectivamente.}
\end{itemize}


\section{Comandos}\label{section:commands}

En la siguiente sección se discutirá la sintaxis y semántica de los comandos en Chloe, así como las funciones y los programas escritos en el lenguaje.
Ademas, se discutirán algunas suposiciones que la semantica toma que causan restricciones en la misma.

\subsection{Sintaxis}\label{subsection:syntax_commands}

Chloe contiene los siguientes constructores: asignación, secuenciación, condicionales, ciclos, SKIP\footnote{El comando SKIP es el equivalente a noop ya que no realiza operación algna. Se utiliza con el fin de poder expresar otros constructores sintácticos como lo es un condicional sin una rama ELSE}, liberación de memoria, instrucción \verb|return| y funciones.
Las expresiones son aquellas descritas en la sección anterior (~\ref{section:expressions}).

Aquí se procede a describir la \textit{sintaxis abstracta} de loc omandos en el lenguaje Chloe.

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  type_synonym fname = string

  datatype
    com = SKIP
        | Assignl lexp exp
        | Assign  vname exp
        | Seq     com  com
        | If      exp com com
        | While   exp com
        | Free    lexp
        | Return exp
        | Returnv
        | Callfunl lexp fname "exp list"
        | Callfun vname fname "exp list"
        | Callfunv fname "exp list"
  \end{lstlisting}

  \caption{Comandos en Chloe}
  \label{fig:chloe_commands}
\end{figure}

En la figura~\ref{fig:chloe_commands} se encuentra la definición del tipo de datos creado en Isabelle para los comandos, donde \verb|lexp| y \verb|exp| son las expresiones descritas en la sección anterior (~\ref{section:expressions}), \verb|vname| representa los nombres de variables y \verb|fname| representa los nombres de funciones.

Para la asignación se definen dos comandos diferentes, uno de ellos permite la asignación a una variable, mientras que el otro permite la asignación a una ubicación en memoria.
Se necesitan ambos comandos dado que el dominio definidos para las direcciones y los valores enteros es disjunto, por lo tanto, una dirección no puede representar un valor entero y viceversa.

También se tienen dos comandos de retorno, uno de ellos permite retornar de una funcion que posee un valor de retorno, mientras que el otro es para retornar de una función que no lo posee.

Finalemnte, se tienen tres comandos diferentes para llamadas a funciones.
Uno de ellos (\verb|Callfunv|) es para funciones que no poseen un valor de retorno.
Los otros dos dependen de lo que se haga con el valor de retorno de la función, si el valor de retorno debe ser asignado a una variable se utiliza el comando \verb|Callfun| y si el retorno debe ser asignado a una celda en memoria se utiliza el comando \verb|Callfunl|.

En Isabelle se define una sintaxis concreta, la cual facilita la escritura y lectura de comandos en Chloe.
En la tabla~\ref{tab:concrete_syntax} se introduce la sintaxis concreta suponiendo que se tiene $x$ que representa nombres de variables, $a$ que representa expresiones, $c$, $c_1$ y $c_2$ que representan comandos, $y$ que representa expresiones del LHS y $f$ que representa nombres de funciones.
A lo largo del trabajo se continuará utilizando la sintaxis concreta para facilitar la legibilidad.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
  \hline
  \textbf{Abstract syntax} & \textbf{Concrete syntax} \\ [0.5ex]
  \hline \hline
  \verb|Assignl| $y$ $a$ & $y$ \verb|::==| $a$ \\
  \verb|Assign| $x$ $a$ & $x$ \verb|::=| $a$ \\
  \verb|If| $a\ c_{1}\ c_{2}$ & \verb|IF| $a$ \verb|THEN| $c_{1}$ \verb|ELSE| $c_{2}$ \\
  \verb|While a| $c$ & \verb|WHILE| $a$ \verb|DO| $c$ \\
  \verb|Free| $y$ & \verb|FREE| $y$ \\
  \verb|Return| $a$ & \verb|RETURN| $a$ \\
  \verb|Returnv| & \verb|RETURNV| \\
  \verb|Calllfunl| $y\ f\ [a]$ & $y$ \verb|::==| $f$ \verb|(| $[a]$ \verb|)| \\
  \verb|Calllfun| $x\ f\ [a]$ & $x$ \verb|::=| $f$ \verb|(| $[a]$ \verb|)| \\
  \verb|Calllfunv| $f\ [a]$ & \verb|CALL| $f$ \verb|(| $[a]$ \verb|)| \\
  \hline
\end{tabular}

\caption{Equivalencia entre sintaxis abstracta y concreta}
\label{tab:concrete_syntax}
\end{table}


\section{Funciones}\label{section:functions_commands}

En Chloe se tienen funciones que devuelven valores y aquellas que no tienen valor de retorno.
Para las funciones que devuelven un valor es necesario saber que ocurre con ese valor de retorno.
Al retornar de una llamada a función, el valor de retorno o bien debe ser asignado a una variable o a una celda en memoria o debe ser ignorado.
En esta sección no se entrará en detalles para explicar esta decisión de diseño sino que se retrasará hasta la sección~\ref{subsection:cfg} donde se podrá explcar el razonamiento detras de esta decisión de una manera mas adecuada.

Como es visible en la definición de la figura~\ref{fig:fun_def}, una función consiste en un nombre, los parámetros formales, las variables locales y el cuerpo de la función, que es un comando, potencialmente grande, en el lenguaje Chloe.
También se define un predicado que comprueba si una declaración de una función es válida o no.
La declaración de una función se considera válida si y solo si los parámetros de la función y las variables locales tienen nombres distintos.

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  record fun_decl =
    name :: fname
    params :: vname list
    locals :: vname list
    body :: com

  valid_fun_decl :: fun_decl $\Rightarrow$ bool
  \end{lstlisting}

  \caption{Definiciones de funciones}
  \label{fig:fun_def}
\end{figure}

\section{Programas}\label{section:programs_commands}

Un programa en Chloe consiste en un nombre, una lista de variables globales y una lista de funciones como se muestra en la figura~\ref{fig:prog_def}.
En esa misma figura se encuentra la definición de una condición que todo programa válido debe cumplir.

Un programa se considera válido si cumple con todas las siguientes condiciones:

\begin{itemize}
  \item{Los nombres de las variables globales son distintos entre si.}
  \item{Los nombres de las funciones en el programa son diferentes entre si.}
  \item{Cada declaración de función para cada función en el programa debe ser válida.}
  \item{La función main debe estar definida.}
  \item{Ninguno de los nombres de las variables o nombres de funcion en el programa debe ser una palabra clave reservada del lenguaje C o una palabra clave reservada para \textit{testing}.\footnote{Dado que se quiere generar código C de la semántica de Chloe, se debe garantizar que ni los nombres de las variables ni de las funciones son alguna de las palabras claves reservadas en C o alguna de las palabras claves reservadas que se utilizan como nombres de variables en el proceso de \textit{testing}.}}
  \item{Las variables globales y los nombres de las funciones en un programa no pueden ser iguales.}
\end{itemize}



\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  record program =
    name :: string
    globals :: vname list
    procs :: fun_decl list

  reserved_keywords =
    [''auto'', ''break'', ''case'', ''char'', ''const'', ''continue'',
     ''default'', ''do'', ''double'', ''else'', ''enum'', ''extern'',
     ''float'', ''for'', ''goto'', ''if'', ''inline'', ''int'', ''long'',
     ''register'', ''restrict'', ''return'', ''short'', ''signed'',
     ''sizeof'', ''static'', ''struct'', ''switch'', ''typedef'',
     ''union'', ''unsigned'', ''void'', ''volatile'', ''while'',
     ''_Bool'', ''_Complex'', ''_Imaginary'']

  test_keywords =
    [''__test_harness_num_tests'', ''__test_harness_passed'',
     ''__test_harness_failed'', ''__test_harness_discovered'' ]

  definition valid_program :: program $\Rightarrow$ bool where
  valid_program p $\equiv$
      distinct (program.globals p)
    $\bigwedge$ distinct (map fun_decl.name (program.procs p))
    $\bigwedge$ ($\forall$ fd $\in$ set (progarm.procs p). valid_fun_decl fd)
    $\bigwedge$ ( let
         pt = proc_table_of p
       in
         ''main'' $\in$ dom pt
         $\bigwedge$ fun_decl.params (the (pt ''main'')) = [])
   $\bigwedge$ ( let
         prog_vars = set ((program.globals p) @
           collect_locals (program.procs p));
         proc_names = set (map (fun_decl.name) (program.procs p))
       in
         ($\forall$ name $\in$ prog_vars.
           name $\notin$ set (reserved_keywords @ test_keywords)) $\bigwedge$
         ($\forall$ name $\in$ proc_names.
           name $\notin$ set (reserved_keywords @ test_keywords)) $\bigwedge$
         ($\forall$ fname $\in$ proc_names.
           ($\forall$ vname $\in$ set (program.globals p). fname $\neq$ vname)))
  \end{lstlisting}

  \caption{Definiciones de un programa}
  \label{fig:prog_def}
\end{figure}


\section{Restricciones}\label{subsection:restrictions_commands}

Esta semántica hace una suposición con respecto a la máquina en la que el código va a ser ejecutado.
Esta restricción está parametrizada y corresponde a la arquitectura de la máquina en la que el código será ejecutado.
Como se dijo anteriormente, la precisión de los valores enteros puede ser modificada con el fin de hacer que esta semántica sea compatible con diferentes arquitecturas, por ejemplo arquitecturas de 32 bits.

Las suposiciones hechas por esta semántica pueden ser cambiadas al cambiar el parámetro \verb|int_width|, el cual cambiará automáticamente los límites superior e inferior que se tienen para enteros (estos límites se describen en la figura~\ref{fig:int_bounds}).

Con el fin de garantizar las suposiciones hechas por la semántica, más adelante en el proceso de generación de código, se generan aserciones que aseguran que las condiciones que se suponen se cumplan.

Otra restricción en la semántica es que solo funciona para un subconjunto de C donde la semántica es determinística y cualquier comportamiento indefinido se considera como un error en la semántica.
Se pasará a un estado erróneo si la semántica encuentra comportamiento que sea considerado como indefinido por el documento de referencia del lenguaje C~\cite{c99}, un ejemplo de este tipo de comportamiento es ``overflow'' de enteros.


\section{Estados}\label{section:states}

En lenguajes más simples, que solo admiten un conjunto limitado de características tales como asinación, secuenciación de instrucciones, condicionales, ciclos y valores enteros, la representación del estado consite simplemente en una función que mapea los nombres de variables a valores.
En Chloe ese no es el caso, al incluir funciones, memoria dinámica y apuntadores al conjunto de características admitidas, la representación del estado del programa deja de ser una simple función que mapea nombres de variables a valores.
En esta sección se detallan los componentes de la represntación de un estado.
Anteriormente, en la sección~\ref{subsection:semantics_expressions} se explico el concepto de un ``estado visible'', aquí se aclara la diferencia entre ese estado visible y un estado real, también se detallan los componentes del estado de un programa.

\subsection{Valuación}\label{subsection:valuation}

Como se menciono anteriormente, una valuación es simplemente una función que mapea nombres de variables a valores.
El tipo de retorno para esta función es \verb|val option option| que se encarga de modelar tres estados diferentes que puede tener una variable: no definida, no inicializada o posee un valor.


\subsection{Pila de ejecución}\label{subsection:stack}

Chloe admite llamadas a funciones, para poder hacerlo se debe mantener una pila de ejecución en el estado.
Esta pila de ejecución (de ahora en adelante se referirá a la misma simplemente como la pila) consiste en una lista de marcos de pila.
Cada uno de estos marcos de pila contiene información importante acerca de la llamada a la función actual.

En la figura~\ref{fig:stack_def} el tipo definido para un marco de pila es una tupla que contiene un comando en Chloe, una valuación y una ubicación de retorno.
El comando de Chloe corresponde al cuerpo de la función a ejecutar.
La valuación corresponde a las variables locales a la función que fue llamada.
Finalmente, la ubicación de retorno puede ser una de las siguientes: una dirección, una variable o una ubicación de retorno inválida.
Cuando una función retorna una variable pueden suceder varias cosas:
\begin{itemize}
  \item{El valor se asigna a una variable.
  Esto es indicado por la ubicación de retorno correspondiente a una variable.}
  \item{El valor se asigna a una celda en memoria.
  Esto es indicado por la ubicación de retorno correspondiente a una dirección.}
  \item{El valor es ignorado.
  Esto es indicado por la ubicación de retorno inválida.}
\end{itemize}

También se utiliza la ubicación de retorno inválida para las funciones que no poseen un valor de retorno.

La ubicación de retorno se encuentra en el marco de pila del llamador, es decir, al retornar de una función el marco del llamador es el que debe ser revisado para saber a donde asignar el valor de retorno o si un valor de retorno es esperado.
Para aclarar esto podemos tomar el ejemplo de código en la figura~\ref{fig:stack_example}.
Es un programa sencillo donde una función que suma el valor de sus dos parámetros se define y luego se llama desde la función main.
Antes de la llamada a función, el marco de pila perteneciente a la función main tiene una ubicación de retorno $Invalid$ y luego de la llamada a función la ubicación de retorno cambia a la variable $x$.
Observe que el marco de pila que cambia su ubicación de retorno es aquel correpondiente a main, esto es porque el llamador es el que debe guardar la ubicación de retorno donde espera guardar el valor de retorno de una función llamada.
Una ubicación de retorno $Invalid$ indica que el llamador no espera guardar resultado alguno, es decir, el llamador no ha llamado aun a alguna función o la función llamada no tiene valor de retorno.

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  datatype return_loc = Ar addr | Vr vname | Invalid

  type_synonym stack_frame = com $\times$ valuation $\times$ return_loc
  \end{lstlisting}

  \caption{Stack definitions}
  \label{fig:stack_def}
\end{figure}

\begin{comment}
\begin{figure}
  \begin{subfigure}{0.3\textwidth}
  \begin{lstlisting}[mathescape=true]
  int sum(int a; int b){
    return a+b;
  }

  int main(){
    int x = 0;
    x = sum(2,2);
  }
  \end{lstlisting}
  \caption{Example code in C}
  \label{fig:stack_ex_c_code}
  \end{subfigure}
  \begin{subfigure}{0.3\textwidth}
    \begin{tabular}{|c|}
      \hline
      \hline
      $\vdots$ \\
      \\
      \hline
      $(x = \mathtt{sum}(2,2),$ \\
      $[x \mapsto 0],$ \\
      $ Invalid )$ \\
      \hline \hline
    \end{tabular}
  \caption{Stack before function call (Stack grows upwards)}
  \label{fig:stack_bef_fun_call}
  \end{subfigure}
  \begin{subfigure}{0.3\textwidth}
    \begin{tabular}{|c|}
      \hline
      \hline
      $\vdots$ \\
      \\
      \hline
      $(\mathtt{return}\ a+b,$ \\
      $[a \mapsto 2, b \mapsto 2],$ \\
      $ Invalid )$ \\
      \hline
      $(x = f(2,2),$ \\
      $[x \mapsto 0],$ \\
      $ x )$ \\
      \hline \hline
    \end{tabular}
  \caption{Stack after function call (Stack grows upwards)}
  \label{fig:stack_aft_fun_call}
  \end{subfigure}

  \caption{Ejemplo de convención de llamada}
  \label{fig:stack_example}
\end{figure}
\end{comment}

\subsection{Tabla de procedimientos}\label{subsection:procedure_table}

Otra extensión que debemos agregar al tratar con funciones es una tabla de procedimientos.
Una tabla de procedimientos se define como sigue:

\begin{lstlisting}[mathescape=true, frame=single]
type_synonym proc_table = fname $\rightharpoonup$ fun_decl
\end{lstlisting}

donde ``$\rightharpoonup$ \verb|fun_decl|'' es equivalente a escribir ``$\Rightarrow$ \verb|fun_decl option|''.
Esta función mapea nombres de funciones a sus declaraciones.

Esta función se construye tomando la definición del programa y emparejando cada declaración de función en la lista a su nombre.
Cada programa tiene su propia tabla de procedimientos.


\subsection{Estado}\label{subsection:state}

Un estado se define como una tupla que contiene la pila, la valuación para las variables globales y la memoria dinámica.

\begin{lstlisting}[mathescape=true, frame=single]
type_synonym state = stack_frame list $\times$ valuation $\times$ mem
\end{lstlisting}

\subsection{Initial State}\label{subsection:initial_state}

Con el fin de construir un estado inicial se deben definir ciertos componentes.
En la figura~\ref{fig:prog_def} se encuentran definiciones para la configuración inicial de la pila, las variables globales y la memoria.
La configuración inicial para la pila consiste en la pila que contiene únicamente el marco de pila para la función main del programa.
La configuración inicial para la valuación global es una función donde cada posible nombre de variable se mapea al valor correspondiente a una variable no definida (\verb|None|).
La configuración inicial de la memoria dinámica es la memoria vacia, dado que nada ha sido asignado.

Luego de definir todos estso componentes, la configuracion del estado inicial es dada por la tupla que contiene la configuración inicial de la pila, las variables globales y la memoria dinámica.


\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  context fixes $program$ :: program begin

    private definition proc_table $\equiv$ proc_table_of program

    definition main_decl $\equiv$ the (proc_table ''main'')
    definition main_local_names $\equiv$ fun_decl.locals main_decl
    definition main_com $\equiv$ fun_decl.body main_decl

    definition initial_stack :: stack_frame list where
      initial_stack $\equiv$ [(main_com,
        map_of (map ($\lambda$. (x,None)) main_local_names),Invalid)]
    definition initial_glob :: valuation where
      initial_glob $\equiv$ map_of (map ($\lambda$. (x,None)) (program.globals program))
    definition initial_mem :: mem where initial_mem $\equiv$ []

    definition initial_state :: state where
      initial_state $\equiv$ (initial_stack, initial_glob, initial_mem)

  end
  \end{lstlisting}

  \caption{Construcción del estado inicial}
  \label{fig:init_state_building}
\end{figure}



\subsection{Estado visible}\label{subsection:visible_state}

Adicionalmente, se debe definir un estado visible (como se mencionó anteriormente en la sección~\ref{paragraph:visible_state}).
Al ejecutar una función transformadora\footnote{las funciones transformadoras se cubrirán más adelante en la sección~\ref{section:small_step}} sobre un estado (exceptuando las funciones transformadoras para las llamadas o retornos de funciones) la misma no podrá modificar alguna otra parte de la pila que no sea la valuación de variables locales del marco de pila actual.
Se definen las transformaciones reales en el contexto de estados visibles y luego se levanta esta definición a estados.
Por lo tanto, una función transformadora sobre estados, con excepción de las llamadas o retornos de funciones, no puede manipular la pila.

El marco de pila en el tope de la pila corresponde a la función actual que está siendo ejecutada y el comando en ese marco de pila corresponde al comando (o programa) en Chloe que está siendo ejecutado.
Cada vez que se ejecuta un comando o se toma un paso en la semántica de pasos cortos, este comando se actualiza para contener el próximo comando a ejecutar.
Con el fin de demostrar que la semántica de pasos cortos es determinística se debe demostrar que cada vez que se tiene una pila de ejecución no vacía, el orden en que se aplica el transformador de evaluación\footnote{Este transformador es la función eval levantada para trabajar en estados en lugar de estados visibles, se discutirá con mayor detalle en la sección~\ref{section:small_step}} y la función que actualiza el comando a ejecutar a continuación es irrelevante para el estado final resultante.
Es por ello que se introduce una definición separada para un estado visible aparte de la de un estado regular, es una vista del mismo estado completo pero con informacion limitada.

\section{Small Step Semantics}\label{section:small_step}

\begin{comment}
add a little summary here.
\end{comment}

\subsection{CFG}\label{subsection:cfg}

A Control Flow Graph is a graph representation that covers the different paths a program can take during its execution.
We have the concept of a current location which is a program pointer to a node.
A command can be executed by following edges from the node pointed to by the program pointer to a new node.
The nodes in our CFG are commands.
The edges in our CFG are annotated with two functions that depend on the current program state.
The first one indicates whether an edge can be followed or not (for example, in the case of a conditional) and the second one indicates how the state is transformed by following the edge i.e.\ the effect that following the edge has on the state.
We call these two functions \textit{enabled} and \textit{transformer} functions.
We will now describe in detail the definitions for these functions.


\paragraph*{Enabled functions}\label{paragraph:enabled}

An enabled function is a partial function as follows:

\begin{lstlisting}[mathescape=true, frame=single]
type_synonym enabled = state $\rightharpoonup$ bool
\end{lstlisting}

It indicates whether a state is enabled to continue its execution.
This is a partial function, therefore its execution might fail.
The execution of an enabled function will fail whenever an error is encountered when evaluating the function and it yields a \verb|None| value indicating an erroneous state.

This function is useful for the execution of conditional constructs in our language.

Suppose we have the term ``\verb|IF| $b$ \verb|THEN| $c_{1}$ \verb|ELSE| $c_{2}$''.
When the evaluation of the condition $b$ yields a \verb|True| value we will follow the edge that leads us to the node that contains $c_1$.
Whereas when the evaluation of $b$ yields a \verb|False| value we will follow the edge that leads us to the node that contains $c_2$.
Depending on the result of the enabled function we will decide whether the term is enabled to follow one edge or the other.
The only case where an execution would not be able to continue is when there is no enabled edge to follow.
Fortunately, this cannot happen in our programs as there is always an enabled edge.
Except for the conditional construct, for every command supported by Chloe the enabled function will always yield \verb|True|.
In the case of a conditional construct, the execution can either continue its execution by following the edge to the first command or by following the edge to the second command.
There will always be an edge that can be followed after a node that contains a conditional

A list of the enabled functions we use is shown in figure~\ref{fig:enabled_def}.
The function \verb|truth_value_of| maps a value to a boolean value, namely \verb|True| or \verb|False|.
We also find \verb|en_always| which always yields \verb|True|, the \verb|en_pos| function which only yields \verb|True| when the truth value of the expression given as a parameter evaluates to \verb|True| and the \verb|en_neg| function which only yields \verb|True| when the truth value of the expression given as a parameter evaluates to \verb|False|.
These functions will be used later in the CFG definition.

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  fun truth_value_of :: val $\Rightarrow$ bool where
    truth_value_of NullVal $\longleftrightarrow$ False
  | truth_value_of (I $i$) $\longleftrightarrow$ $i$ $\neq$ $0$
  | truth_value_of (A _) $\longleftrightarrow$ True

  abbreviation en_always :: enabled where en_always $\equiv\ \lambda$_. Some True

  definition en_pos :: exp $\Rightarrow$ enabled

  definition en_neg :: exp $\Rightarrow$ enabled
  \end{lstlisting}

  \caption{Enabled functions}
  \label{fig:enabled_def}
\end{figure}


\paragraph*{Transformer functions}\label{paragraph:transformer}

A transformer function is a partial function as follows:

\begin{lstlisting}[mathescape=true, frame=single]
type_synonym transformer = state $\rightharpoonup$ state
\end{lstlisting}

It is a partial function that transforms a state into another.
Since it is a partial function, its execution might fail.
The execution of a transformer function will fail whenever an error is encountered at some point of its execution and yield a \verb|None| value indicating an erroneous state.

We define functions that will return a transformer function for each command in Chloe.
These functions will be used later in the CFG definition and are defined in figure~\ref{fig:transformer_def}
We define a transformer function \verb|tr_id| that will serve as the id function and simply yields the same state it is given as a parameter.

The definitions listed in figure~\ref{fig:transformer_def} yield a transformer function which we will use when executing a command.
We proceed to roughly describe the effect the transformer functions yielded will have when applied to a state.

First of all we have the transformer for an assignment yielded by \verb|tr_assign|, it will evaluate the expression we want to assign and then proceed to perform a \verb|write| operation to the state and it yields the state resulting from this evaluation and \verb|write| operation.

The transformer for an assignment to a cell in the dynamic memory yielded by \verb|tr_assignl| will first evaluate the LHS expression to obtain the location in memory where the value will be updated, then it will evaluate the expression to obtain the new value and proceed to store the value in memory, it yields the state resulting from the evaluations and the \verb|store| operation.

The transformer for an evaluation yielded by \verb|tr_eval| will evaluate the expression and yield the state resulting from the evaluation.

The transformer for a free operation yielded by \verb|tr_free| will evaluate the LHS expression it receives as a parameter in order to obtain an address and the block for this address will be deallocated.
The transformer will yield the state resulting from the evaluation and deallocation of memory.

When performing a function call one must check that the formal parameters and the actual parameters given to the function have the same type and that each formal parameter has a corresponding given parameter.
Since we do not have a static type system we will only check the second condition mentioned.
Furthermore, we fix the evaluation order for the parameters given to a function as left to right order.
The parameters will always be evaluated following a left to right order.
Finally when calling a function we must also map the formal parameters to the values of the given parameters and regard these as local variables in the scope of our function.

We have a \verb|call_function| which yields a transformer function for any function call, this transformer checks that the number of formal parameters and given parameters is the same, it evaluates the given parameters from left to right, it creates a new stack frame containing the body of the function, the local variables valuation (which includes the parameters mapped to their given values and the local variables mapped to an uninitialized value) and the return location \verb|Invalid|, it yields the state resulting from performing these operations over the state.

When calling a function the caller has to change its stack frame in order to update the return location value in the current stack frame.
We define different functions that perform that change depending on the type of function call and then proceed to yield a transformer by calling \verb|call_function|.

The different functions we define are \verb|tr_callfunl|, \verb|tr_callfun| and \verb|tr_callfunv|.
We use \verb|tr_callfunl| when the return location of the function is a cell in memory.
In this case the function first evaluates the LHS expression to obtain the return address and updates the return location of the stack frame with it before calling \verb|call_function|, the resulting transformer function will yield a state resulting from this evaluation, the update of the stack frame and the operations done by \verb|call_function|.
It is important here that the evaluation of the LHS expression that yields an address value must be the first one done, this is in order to avoid unwanted behavior since the function could change the state.

We use \verb|tr_callfun| when the return location of the function is a variable.
In this case the function updates the return location of the stack frame with the variable name before calling \verb|call_function|, the resulting transformer function will yield a state resulting from this update of the stack frame and the operations done by \verb|call_function|.

We use \verb|tr_callfunl| when the function is not expected to return a value.
In this case the function updates the return location of the stack frame with \verb|Invalid| before calling \verb|call_function|, the resulting transformer function will yield a state resulting from this update of the stack frame and the operations done by \verb|call_function|.

We have a \verb|tr_return| which yields a transformer function for a return call returning an expression in a function, this transformer will pop the last stack frame in the stack belonging to the returning function, evaluate the value corresponding to the expression returned by the function and if the stack is not empty then proceed to retrieve the return location and depending on if it is an address, a variable or an invalid location it will yield the state resulting from storing the value in memory, writing the value to a variable or yield the state as it is, respectively as well as popping the last stack frame of the stack.
Note that if the function returns a value but its return location is expected to be invalid then the returned value is ignored instead of being considered an erroneous execution.

Finally we have a \verb|tr_return_void| which yields a transformer function for a return call in a function which has no return value.
This transformer will pop the last stack frame belonging to the returning function.
Subsequently, if the stack is not empty it will obtain the return location.
If the return location is anything different from an invalid return location it will return a \verb|None| value which represents an error.
However, if the return location is, in fact, an invalid one then it will yield the state resulting from the last frame of the stack being popped.

\begin{comment}
FIXME
\end{comment}

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  abbreviation (input) tr_id :: transformer where tr_id $\equiv$ Some

  tr_assign :: vname $\Rightarrow$ exp $\Rightarrow$ transformer
  tr_assignl :: lexp $\Rightarrow$ exp $\Rightarrow$ transformer
  tr_eval :: exp $\Rightarrow$ transformer
  tr_free :: lexp $\Rightarrow$ transformer
  call_function :: proc_table $\Rightarrow$ fname $\Rightarrow$ exp list $\Rightarrow$ transformer
  tr_callfunl :: proc_table $\Rightarrow$ lexp $\Rightarrow$ fname $\Rightarrow$ exp list $\Rightarrow$ transformer
  tr_callfun :: proc_table $\Rightarrow$ vname $\Rightarrow$ fname $\Rightarrow$ exp list $\Rightarrow$ transformer
  tr_callfunv :: proc_table $\Rightarrow$ fname $\Rightarrow$ exp list $\Rightarrow$ transformer
  tr_return :: exp $\Rightarrow$ transformer
  tr_return_void :: transformer
  \end{lstlisting}

  \caption{Transformer functions}
  \label{fig:transformer_def}
\end{figure}


\paragraph*{CFG}

In order to talk about executions by following edges in the CFG we must introduce yet another concept.
Taking the definition given at the beginning of this section of what a CFG is we know that in order to talk about an execution of a command by following the edges of the CFG we must have a program pointer that indicates the current node.
We also need to introduce the concept of a stack.
We will have a stack of program pointers to accompany our CFG and we will pop a new program pointer from the stack once we have \verb|followed| the current pointer up to a \verb|SKIP| node.
A program pointer to the command of a function will be pushed to the stack when there is a function call.
A program pointer will be popped from the stack when there is a return command.
This concept will become important when talking about function calls and return commands further ahead.

We can see an inductive definition in figure~\ref{fig:cfg_rules} for CFG, where we can see the rules to form edges between commands.
We can follow an edge in the CFG from an assignment to a variable to \verb|SKIP|.
This edge is always enabled and has a transformer function to update the state which is given by the result of \verb|tr_assign| called with the parameters specific for the command.

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  type_synonym cfg_label = enabled $\times$ transformer

  inductive cfg :: com $\Rightarrow$ cfg_label $\Rightarrow$ com $\Rightarrow$ bool where

    Assign: cfg ($x$ ::= $a$) (en_always,tr_assign $x$ $a$) SKIP
  | Assignl: cfg ($x$ ::==  $a$) (en_always,tr_assignl $x$ $a$) SKIP
  | Seq1: cfg (SKIP;; $c_{2}$) (en_always, tr_id) $c_{2}$
  | Seq2: $[\![$cfg $c_{1}$ $a$ $c_{1}'$ $]\!]$ $\Longrightarrow$ cfg ($c_{1}$;; $c_{2}$) $a$ ($c_{1}'$;; $c_{2}$)
  | IfTrue: cfg (IF $b$ THEN $c_{1}$ ELSE $c_{2}$) (en_pos $b$, tr_eval $b$) $c_{1}$
  | IfFalse: cfg (IF $b$ THEN $c_{1}$ ELSE $c_{2}$) (en_neg $b$, tr_eval $b$) $c_{2}$
  | While: cfg (WHILE $b$ DO $c$) (en_always, tr_id)
      (IF $b$ THEN $c$;; WHILE $b$ DO $c$ ELSE SKIP)
  | Free: cfg (FREE $x$) (en_always, tr_free $x$) SKIP

  | Return: cfg (Return $a$) (en_always, tr_return $a$) SKIP
  | Returnv: cfg Returnv (en_always, tr_return_void) SKIP

  | Callfunl: cfg (Callfunl $e$ $f$ params)
      (en_always, tr_callfunl proc_table $e$ $f$ params) SKIP
  | Callfun: cfg (Callfun $x$ $f$ params)
      (en_always, tr_callfun proc_table $x$ $f$ params) SKIP
  | Callfunv: cfg (Callfunv $f$ params)
      (en_always, tr_callfunv proc_table $f$ params) SKIP
  \end{lstlisting}

  \caption{CFG rules}
  \label{fig:cfg_rules}
\end{figure}

Likewise, an edge in the CFG can be followed from an assignment to a cell in memory to \verb|SKIP|, this edge is always enabled and the transformer function to update the state is given by the result of \verb|tr_assignl| called with the parameter specific for the command.

The sequential composition has two different edges that can be followed.
When the first command in the sequential composition is a \verb|SKIP| command we can follow an edge that will lead us from the node with the whole command to a node with only the second command.
This edge is always enabled and the transformer over the state is the \verb|tr_id|.
The second case occurs when we have a command of the form \verb|(| $c_{1}$ \verb|;;| $c_{2}$ \verb|)| where $c_{1}$ is not \verb|SKIP|.
If we follow an edge from $c_{1}$ to some other node $c_{1}'$ (where the edge is labelled $a$), which contains an enabled and a transformer function, then we can follow an edge (also labelled with $a$) from \verb|(| $c_{1}$ \verb|;;| $c_{2}$ \verb|)| to \verb|(| $c_{1}'$ \verb|;;| $c_{2}$ \verb|)|.

We also have two cases when it comes to the case of the conditional.
We will have the possibility to follow an edge to the first command or an edge to the second command, depending on the value of the guard.
In the case where we follow the edge that leads us to the first command, we will go from \verb|IF| $b$ \verb|THEN| $c_{1}$ \verb|ELSE| $c_{2}$ to $c_{1}$.
This edge will be labelled with an enabled function given by \verb|en_pos| which will be enabled only when the condition $b$ evaluates to \verb|True| and with a transformer function given by \verb|tr_eval|.
In the case where we follow the edge that leads us to the second command, we will go from \verb|IF| $b$ \verb|THEN| $c_{1}$ \verb|ELSE| $c_{2}$ to $c_{2}$.
This edge will be labelled with an enabled function given by \verb|en_neg| which will be enabled only when the condition $b$ evaluates to \verb|False| and with a transformer function given by \verb|tr_eval|.

In the case of a loop we can always follow an edge that takes us from \verb|WHILE| $b$ \verb|DO| $c$ to \verb|IF| $b$ \verb|THEN| $c$ \verb|;; WHILE| $b$ \verb|DO| $c$ \verb|ELSE SKIP| by unrolling the loop once.
The edge will have an enabled function that is always enabled and the transformer over the state is the \verb|tr_id|.

We can follow an edge from \verb|FREE| $x$ to \verb|SKIP|.
This edge is always enabled and a has transformer function given by the result of \verb|tr_free| called with $x$.

We can follow an edge from any of the two existing return commands to \verb|SKIP|.
This edge is always enabled and has a transformer function given by the result of \verb|tr_return| or \verb|tr_return_void| depending on which return command it is.
Note that when \textit{executing} this command in the CFG, following the edge from a return node to a \verb|SKIP| node will pop the program pointer pointing to the \verb|SKIP| node and we will continue our ``execution'' in the location pointed by the next program pointer in the stack.

Finally, we can follow an edge from any of the function call nodes to \verb|SKIP|.
This edge is always enabled and has a transformer function given by the result of either \verb|tr_callfunl|, \verb|tr_callfun| or \verb|tr_callfunv| depending on whether it is a function call that returns to a memory cell, a variable or returns no value.
Note that, also in this case, when \textit{executing} this command in the CFG, following the edge from a function call node to a \verb|SKIP| node will push a new program pointer to the stack that points to the location of the node that contains the command of the function and we will continue our ``execution'' in the location pointed by this next program pointer.

\subsection{Small Step semantics rules}\label{subsection:rules_small_step}

Finally, we introduce the rules for the small-step semantics for Chloe.
A small-step semantics is chosen over a big-step definition for the semantics due to the fact that we want a finer grained semantics.
The big-step semantics has a major drawback, which is that it cannot differentiate between a non-terminating execution and getting stuck in an erroneous configuration.
This is why we prefer a more detailed semantics that allows us to differentiate between nontermination and getting stuck because it allows us to talk about intermediate states during evaluation.

Usually a configuration in a small step semantics is a pair consisting of a command and a state.
Since we are working with functions and we have the command that is being executed in the stack frame our small-step definition is defined over states.
A small, atomic step can be taken from one state to another.

The small-step rules for the semantics are detailed in figure~\ref{fig:small_step_rules}.
The infix syntax for the small step semantics is written as $s \rightarrow s_{2}$ which means we take a small step from $s$ to $s_{2}$.
A step can be taken if the following conditions are met:

\begin{itemize}
  \item{The stack is not empty.}
  \item{There is a CFG edge between $c_{1}$ and $c_{2}$.}
  \item{The command at the topmost stack frame in the initial state is $c_{1}$.}
  \item{Applying the enabled function over the state yields \verb|True|.}
  \item{Applying the transformer function to the state with the command at the topmost stack frame updated from $c_{1}$ to $c_{2}$ yields a new state $s_{2}$.}
\end{itemize}

Given that all the previous conditions are fulfilled then a small step can go from state $s$ to $s_{2}$.

A small step can also be taken upon return from a function which returns no value.
If the command at the top of the stack is \verb|SKIP|, the stack is not empty and applying the transformer function on the initial state $s$ yields a new state $s_{2}$, then we can take a small step from $s$ to $s_{2}$

The type for \verb|small_step| is from \verb|state| to \verb|state option|.
The second configuration is enclosed in an option type because taking a small step can result in an erroneous state in which we will get stuck.

A small step can fail to be taken in any of the following cases:

\begin{itemize}
  \item{Either the enabled function or the transformer function yield \verb|None| when evaluated over the initial state.
  This indicates an erroneous state was reached when evaluating one of those functions.
  We propagate the erroneous state by taking a small step from state $s$ to \verb|None| and then the execution will get stuck there.}
  \item{If applying the transformer function \verb|tr_return_void| over the state yields a \verb|None| value, the command at the top of the stack in the initial state is \verb|SKIP| and the stack is not empty, then we also propagate this erroneous \verb|None| state by taking a small step from $s$ to None.
  This indicates there was an error returning from a function without a return value.}
\end{itemize}

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  inductive
    small_step :: state $\Rightarrow$ state option $\Rightarrow$ bool (infix $\rightarrow$ 55)
  where
    Base: $[\![$ $\neg$ is_empty_stack $s$; $c_{1}$=com_of $s$; cfg $c_{1} (en, tr) $c_{2};
      en $s$ = Some True; tr (upd_com $c_{2}$ $s$) = Some $s_{2}$ $]\!]$ $\Longrightarrow$ s $\rightarrow$ Some $s_{2}$
  | None: $[\![$ $\neg$ is_empty_stack $s$; $c_{1}$=com_of $s$; cfg $c_{1} (en, tr) $c_{2};
      en $s$ = None $\vee$ tr (upd_com $c_{2}$ $s$) = None$]\!]$ $\Longrightarrow$ s $\rightarrow$ None
  | Return_void: $[\![$ $\neg$ is_empty_stack $s$; com_of $s$ = SKIP;
      tr_return_void $s$ = Some $s'$ $]\!]$ $\Longrightarrow$ $s$ $\rightarrow$ Some $s'$
  | Return_void_None: $[\![$ $\neg$ is_empty_stack $s$; com_of $s$ = SKIP;
      tr_return_void $s$ = None $]\!]$ $\Longrightarrow$ $s$ $\rightarrow$ None

  inductive
    small_step' :: (state) option $\Rightarrow$ (state) option $\Rightarrow$ bool (infix $\rightarrow'$  55)
  where
    $s\ \rightarrow\ s'\ \Longrightarrow$ Some $s\ \rightarrow'\ s'$

  abbreviation
    small_steps :: (state) option $\Rightarrow$ (state) option $\Rightarrow$ bool (infix $\rightarrow*$ 55)
  where $s_{0}$ $\rightarrow*$ $s_{f}$ ==  star small_step' $s_{0}$ $s_{f}$
  \end{lstlisting}

  \caption{Small-step rules}
  \label{fig:small_step_rules}
\end{figure}

We have defined how to take a single step in our semantics.
In order to take more than one step and define the execution of a program in our semantics we must lift the definition of \verb|small_step| to \verb|state option| in both the initial and the final state.

We also define (in figure~\ref{fig:small_step_rules}) a new \verb|small_step'| based on our previous definition of \verb|small_step|.
This definition essentially says that if a small step can be taken from state $s$ to state $s'$ then a small step can be taken from \verb|Some| $s$ to $s'$.
Note that $s'$ can either be a \verb|None| value or a \verb|Some| $s_{i}$.
The infix syntax for this new \verb|small_step'| is written as \verb|Some| $s \rightarrow' s'$, which means we take a small step from \verb|Some| $s$ to $s'$.

In this manner, we have lifted our small step definition to the type \verb|state option| and we can define the execution of a program as the reflexive transitive closure of the newly defined \verb|small_step'|, using Isabelle's \verb|star| operator.
The infix syntax for this is written as $s_{0} \rightarrow* s_{f}$, which means we can go from state $s_{0}$ to $s_{f}$ in zero or more small steps.


\subsubsection*{Determinism}

To be able to make our semantics executable inside of the Isabelle/HOL environment it must be deterministic.
This is why we prove the determinism property for the semantics.
In order to go through with that proof a set of lemmas must be first defined and proved.
We will proceed to explain such defined lemmas for our semantics in this section.

Whenever we introduce a lemma, next to its number we will have a name in parenthesis.
This corresponds to the name of the lemma in the Isabelle source files submitted with this work.
In the case where the reader is interested in the exact proof for a particular lemma he or she can search for the corresponding lemma in the theory files and read the proof.

This first lemma indicates that whenever we have a command different from \verb|SKIP| there is either always an enabled action to take in the CFG or an error occurs when trying to evaluate the enabled function.

\begin{lemma}[cfg\_has\_enabled\_action]
$\newline$
$c$ $\neq$ \verb|SKIP| $\Longrightarrow$ $\exists\ c'\ en\ tr$. \verb|cfg| $c\ (en,tr)\ c'\ \wedge\ (en\ s\ =$ \verb|None| $\vee\ en\ s\ =$ \verb|Some True|$)$
\label{lemma:cfg_enabled_action}
\end{lemma}

\begin{proof}
The proof is by induction on the command.
Except for two cases the proof is solved automatically.
Those interesting cases are the \verb|Seq| and the \verb|If| cases.
In the \verb|Seq| case we need to make a further case distinction on the first command of the sequential composition in order to differentiate the cases where it is \verb|SKIP| and when it is not.
In both cases there is a CFG rule that ensures there is an enabled action and the case is solved automatically.

In the \verb|If| case we need to make a case distinction over the value of $\mathtt{en\_pos}\ b\ s$.
It can fail and return a None value, then the case is solved.
If it does not fail then we must check the boolean value returned by the \verb|en_pos| function.
In the case where it is \verb|True| then the case is solved.
The challenging case comes when the evaluation of \verb|en_pos| is \verb|False|, semantically, this means the else branch should be taken instead.
Therefore when $\mathtt{en\_pos}\ b\ s$ is \verb|False|, $\mathtt{en\_neg}\ b\ s$ will always evaluate to \verb|True|, this means that the command will have an enabled action, namely $\mathtt{en\_neg}\ b\ s$ and the proof of this case is complete.
\end{proof}

Next we want to prove that as long as the stack is not empty the small-step semantics can always take a step.
We will make use of the previous lemma in the proof for this new lemma.
This lemma states that the semantics can take a step.

\begin{lemma}[can\_take\_step]
$\newline$
$\neg$ \verb|is_empty_stack| $s$ $\Longrightarrow$ $\exists\ x.\ s\ \rightarrow\ x$
\label{lemma:can_take_step}
\end{lemma}

\begin{proof}
From the assumptions we know that the stack is not empty, therefore we can rewrite the state as follows: $s = ((c, locals, rloc)\#\sigma,\gamma,\mu)$.
We can then do a proof by cases.
We have the case where $c\ =\ \mathtt{SKIP}$ and the case where $c\\neq\ \mathtt{SKIP}$.

The case where $c\ =\ \mathtt{SKIP}$ is the case where we are returning from the execution of a function.
We know that the stack is not empty, that $c\ =\ \mathtt{SKIP}$ and that $s = ((c, locals, rloc)\#\sigma,\gamma,\mu)$.
This case corresponds to the \verb|Return_void| and \verb|Return_void_None| rules in the definition of \verb|small_step|.
In both these cases the semantics can take a step, either to some new state $s'$ or to \verb|None|.
This goal is solved automatically by Isabelle indicating the mentioned rules and assumptions.

The second case is where $c\\neq\ \mathtt{SKIP}$.
This is the case when we are executing any other command and not returning from a function.
In this case we use the previous lemma~\ref{lemma:cfg_enabled_action} and from that we know that $\mathtt{cfg}\ c\ (en,tr)\ c'$ and either the enabled function fails ($\mathtt{en}\ s\ = \mathtt{None}$) or it is enabled ($\mathtt{en}|\ s\ = \mathtt{Some True}$).

We prove this subgoal by splitting it into cases.
In the first case we assume $\mathtt{cfg}\ c\ (en,tr)\ c'$ and $\mathtt{en}\ s\ = \mathtt{None}$.
This is the case where the evaluation function fails, we know this case takes a step to None because of the \verb|None| case of the small step definition.
Then we have proved that it exists a state so that $s\ \rightarrow\ \mathtt{None}$.

In the next case we assume $\mathtt{cfg}\ c\ (en,tr)\ c'$ and $\mathtt{en}\ s\ = \mathtt{Some True}$.
This is the case where we are enabled to take a step and we must still check two more cases.
Applying the transformer function over the state updated with the command ($tr\ (upd\_com\ c'\ s)$) can either fail or not.
In the case it fails (it returns \verb|None|) we can take a step to \verb|None| and we will have proved that there is a state to which $s$ can take a small step, namely \verb|None|.
In the case it does not fail, it will return $\mathtt{Some}\ s_{2}$.
In this case we can take a step to $\mathtt{Some}\ s_{2}$ and we will have proved that there is a state to which $s$ can take a small step, namely $\mathtt{Some}\ s_{2}$.
\end{proof}

We define several lemmas that will come in handy later on.

The first lemma states that the CFG gets stuck at SKIP:
\begin{lemma}[cfg\_SKIP\_stuck]
$\newline$
$\neg$ \verb|cfg SKIP| $a\ c$
\label{lemma:stuck_at_skip}
\end{lemma}

\begin{proof}
The property is proved automatically.
\end{proof}


\begin{lemma}[ss\_empty\_stack\_stuck]
$\newline$
\verb|is_empty_stack| $s$ $\Longrightarrow$ $\neg$ $(s\ \rightarrow\ cs')$
\label{lemma:ss_empty_stack_stuck}
\end{lemma}

\begin{proof}
The property is proved automatically.
\end{proof}


\begin{lemma}[ss'\_SKIP\_stuck]
$\newline$
\verb|is_empty_stack| $s$ $\Longrightarrow$ $\neg$ $(Some s\ \rightarrow\ cs')$
\label{lemma:ss'_empty_stack_stuck}
\end{lemma}

\begin{proof}
The property is proved automatically.
\end{proof}

Lemmas~\ref{lemma:ss_empty_stack_stuck} and~\ref{lemma:ss'_empty_stack_stuck} define the final state in which the semantics will get stuck, the semantics will get stuck when there are no more stack frames in the stack.


\begin{lemma}[en\_neg\_by\_pos]
$\newline$
\verb|en_neg| $e\ s$ = \verb|map_option (HOL.Not) (en_pos| $e\ s$ \verb|)|
\label{lemma:en_neg_by_pos}
\end{lemma}

\begin{proof}
The property is proved automatically unfolding the definitions of \verb|en_neg| and \verb|en_pos|.
\end{proof}

Lemma~\ref{lemma:en_neg_by_pos} states that every time the enabled function \verb|en_neg| has a value (different than None) over a state, \verb|en_pos| will have the same but opposite result.
In the case where one of the functions fails the other one will too, and they will yield \verb|None|.
If they do not fail their results will be opposite, that is, if one has \verb|Some True| as a result, the other one will have \verb|Some False| as a result.
This lemma will come in handy when proving determinism.

\begin{lemma}[cfg\_determ]
$\newline$
$\mathtt{cfg}$ $c$ $a1$ $c'$ $\wedge$
$\mathtt{cfg}$ $c$ $a2$ $c''$
$\newline$
$\Longrightarrow$
$a1\ =\ a2$ $\wedge$ $c'\ =\ c''$ $\vee$
$\newline$
$\exists\ b.\ a1\ = (\mathtt{en\_pos}\ b,\ \mathtt{tr\_eval}\ b)\ \wedge\ a2\ = (\mathtt{en\_neg}\ b,\ \mathtt{tr\_eval}\ b)\ \vee$
$\newline$
$\exists\ b.\ a1\ = (\mathtt{en\_neg}\ b,\ \mathtt{tr\_eval}\ b)\ \wedge\ a2\ = (\mathtt{en\_pos}\ b,\ \mathtt{tr\_eval}\ b)$
\label{lemma:cfg_determ}
\end{lemma}

\begin{proof}
The proof is by induction on the command, with the cases of the \verb|cfg| rules generated by Isabelle all cases are solved automatically.
\end{proof}

Lemma~\ref{lemma:cfg_determ} states that CFG is deterministic.
The only case where it is not is in the conditional case, for which we add an extra alternative in the conclusion.
It can happen that we have a CFG rule starting at an \verb|If| command that has an edge to a $c_{1}$ and also an edge to $c_{2}$.
This is not really a problem since the enabled functions guarantee that whenever that happens only one of the branches can be taken.


\begin{lemma}[lift\_upd\_com]
$\newline$
$\neg\ \mathtt{is\_empty\_stack}\ s\ \Longrightarrow$
$\newline$
$\mathtt{lift\_transformer\_nr}\ tr\ (\mathtt{upd\_com}\ c\ s)\ =$
$\newline$
$\mathtt{map\_option}\ (\mathtt{upd\_com}\ c)\ (\mathtt{lift\_transformer\_nr}\ tr\ s)$
\label{lemma:lift_upd_com}
\end{lemma}

\begin{proof}
It is proved automatically by unfolding the definition of \verb|lift_transformer_nr|.
\end{proof}

\begin{lemma}[tr\_eval\_upd\_com]
$\newline$
$\neg\ \mathtt{is\_empty\_stack}\ s\ \Longrightarrow$
$\newline$
$\mathtt{tr\_eval}\ e\ (\mathtt{upd\_com}\ c\ s)\ =$
$\newline$
$\mathtt{map\_option}\ (\mathtt{upd\_com}\ c)\ (\mathtt{tr\_eval}\ e\ s)$
\label{lemma:tr_eval_upd_com}
\end{lemma}

\begin{proof}
It is proved automatically by unfolding the definition of \verb|tr_eval|.
\end{proof}

The \verb|lift_transformer_nr| function lifts to states the definition of a transformer function that operates in the visible state level.
Lemmas~\ref{lemma:lift_upd_com} states that it does not matter in which order a transformer function is applied over a state and the command in the top of the stack frame is updated, since it will always yield the same result.
This is because the update command function only modifies the command at the top of the stack and the transformer function cannot access and modify that part of the stack since it only modifies the visible state.

Lemma~\ref{lemma:tr_eval_upd_com} is a more specific version of the previous lemma that states the same fact specifically for the evaluation transformer function.


All the previous lemmas and definitions have been building up to this next proof, the determinism of the small step semantics.
\begin{lemma}[small\_step\_determ]
$\newline$
$s\ \rightarrow\ s'\ \wedge\ s\ \rightarrow\ s''\ \Longrightarrow\ s'\ =\ s''$
\label{lemma:small_step_determ}
\end{lemma}

\begin{proof}
The proof is by cases on the small step semantics.
We obtain 4 cases, each corresponding to each rule in the small step semantics.
The goals generated by the \verb|Return_void| and \verb|Return_void_None| rules are solved automatically.
The goals generated by the \verb|Base| and the \verb|None| are solved automatically after adding lemmas~\ref{lemma:en_neg_by_pos} and~\ref{lemma:tr_eval_upd_com}.
\end{proof}

Then we are only left to show that \verb|small_step'| is also deterministic.

\begin{lemma}[small\_step'\_determ]
$\newline$
$s\ \rightarrow'\ s'\ \wedge\ s\ \rightarrow'\ s''\ \Longrightarrow\ s'\ =\ s''$
\label{lemma:small_step'_determ}
\end{lemma}

\begin{proof}
The proof is by cases on the small step semantics.
It is proved automatically by using lemma~\ref{lemma:small_step_determ}.
\end{proof}


\section{Interpreter}\label{section:interpreter}

\subsection{Single step}\label{subsection:single_step}

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  datatype cfg_edge = Base $transformer$ $com$
                    | Cond $enabled$ $transformer$ $com$ $com$

  context fixes proc_table :: proc_table begin

    fun cfg_step :: "com $\Rightarrow$ cfg_edge" where
      "cfg_step SKIP = undefined"
    | "cfg_step ($x$ ::= $a$) = Base (tr_assign $x$ $a$) SKIP"
    | "cfg_step ($x$ ::== $a$) = Base (tr_assignl $x$ $a$) SKIP"
    | "cfg_step (SKIP;; $c_{2}$) = Base tr_id $c_{2}$"
    | "cfg_step ($c_{1}$;;$c_{2}$) = (case cfg_step $c_{1}$ of
        Base $tr$ $c$ $\Rightarrow$ Base tr (c;;c2)
      | Cond $en\ tr\ ca\ cb$ $\Rightarrow$ Cond $en\ tr\ \mathtt{(}ca\mathtt{;;}c2\mathtt{)}\ \mathtt{(}cb\mathtt{;;}c2\mathtt{)}$
       )"
    | "cfg_step (IF $b$ THEN $c_{1}$ ELSE $c_{2}$) = Cond (en_pos $b$) (tr_eval $b$) $c_{1}$ $c_{2}$"
    | "cfg_step (WHILE $b$ DO $c$) =
        Base tr_id (IF $b$ THEN $c$;; WHILE $b$ DO $c$ ELSE SKIP)"
    | "cfg_step (FREE $x$) = Base (tr_free $x$) SKIP"
    | "cfg_step (Return $a$) = Base (tr_return $a$) SKIP"
    | "cfg_step Returnv = Base (tr_return_void) SKIP"
    | "cfg_step (Callfunl $e$ $f$ params) =
        Base (tr_callfunl proc_table $e$ $f$ params) SKIP"
    | "cfg_step (Callfun $x$ $f$ params) =
        Base (tr_callfun proc_table $x$ $f$ params) SKIP"
    | "cfg_step (Callfunv $f$ params) =
        Base (tr_callfunv proc_table $f$ params) SKIP"

  end
  \end{lstlisting}

  \caption{Single step edges}
  \label{fig:single_step_edges}
\end{figure}

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  definition fstep :: proc_table $\Rightarrow$ state $\Rightarrow$ state option where
    fstep proc_table $s$ $\equiv$
      if com_of $s$ = SKIP then
        tr_return_void $s$
      else
        case cfg_step proc_table (com_of $s$) of
            Base $tr\ c'$ $\Rightarrow$ $tr$ (upd_com $c'\ s$)
          | Cond $en\ tr\ c1\ c2$ $\Rightarrow$ do {
              $b$ $\leftarrow$ en $s$;
              if $b$ then
                tr (upd_com $c1\ s$)
              else  
                tr (upd_com $c2\ s$)
            }
  \end{lstlisting}

  \caption{Definition of fstep}
  \label{fig:fstep_def}
\end{figure}

There are two kinds of edges in the CFG.
We create a new datatype for representing them.


A $Base$ edge that has a transformer function and is always enabled and takes us to a new command and a $Cond$ edge that, apart from the transformer function, also has an enabled function and two commands.
This enabled function indicates whether we take a step to the first or the second command.
Also we define a \verb|cfg_step| function that given the starting command returns which kind of edge follows in the CFG.

The function \verb|fstep|, defined in figure~\ref{fig:fstep_def}, is how we take a single step in the execution of the semantics.
An execution of a step in the semantics will take us from an initial state to a new state which can be an erroneous state (\verb|None|) or a valid one (\verb|Some| $s$).
To execute a \verb|SKIP| command we call the transformer function for returning without a value from a function \verb|tr_return_void|.
Otherwise we will check which kind of step we should take by means of the \verb|cfg_Step| function and, based on that, decide what to do.
If it is a \verb|Base| step we will call the transformer function over the state with the updated command.
If, on the other hand, it is a \verb|Cond| step we will evaluate the condition and call the transformer function over the state with the updated command.

\subsubsection*{Equality between small-step semantics and single-step execution}\label{subsubsection:equality_ss_ss}

We must now prove that the single step execution is semantically equivalent to taking a step in the small-step semantics.
This is proving that $\neg\ \mathtt{is\_empty\_stack}\ \Longrightarrow\ s\ \rightarrow\ s'\ \longleftrightarrow\ \mathtt{fstep}\ s\ =\ s'$\footnote{fstep has an extra parameter, namely the procedure table, which we will avoid writing here to make it simpler to read}.
We prove both directions of the equivalence separately: for every step taken in the small-step semantics, there is an equivalent step that can be taken in the execution by \verb|fstep| which will lead to the same final state and vice versa.


We start by showing that any step taken in the small-step semantics can be simulated by a step taken with fstep.

\begin{lemma}[fstep1]
$\newline$
$s\ \rightarrow\ s'\ \Longrightarrow\ \mathtt{fstep}\ s\ =\ s'$
\label{lemma:fstep1}
\end{lemma}

\begin{proof}
This proof is done by induction over the small-step semantics.
\end{proof}

Then we consider the other direction:

\begin{lemma}[fstep2]
$\newline$
$\neg\ \mathtt{is\_empty\_stack}\ s\ \Longrightarrow\ s\ \rightarrow\ (\mathtt{fstep}\ s)$
\label{lemma:fstep2}
\end{lemma}

\begin{proof}
This proof is done automatically by making a case distinction on the result of ``\verb|tr_return_void| $s$'' and using the lemmas~\ref{lemma:can_take_step} and~\ref{lemma:fstep1}.
\end{proof}

Both directions together (Lemma~\ref{lemma:fstep1} and lemma~\ref{lemma:fstep2}) let us then show the equivalence we were aiming for originally:

\begin{lemma}[ss\_fstep\_equiv]
$\newline$
$\neg\ \mathtt{is\_empty\_stack}\ \Longrightarrow\ s\ \rightarrow\ s'\ \longleftrightarrow\ \mathtt{fstep}\ s\ =\ s'$
\label{lemma:ss_fstep_equiv}
\end{lemma}


\subsection{Execution and Interpretation}\label{subsection:exec_interp}

In order to execute a program we will define an interpreter for it.

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  fun is_term :: "state option $\Rightarrow$ bool" where
    "is_term (Some $s$) = is_empty_stack $s$"
  | "is_term None = True"

  definition interp :: "proc_table $\Rightarrow$ state $\Rightarrow$ state option" where
    "interp proc_table $cs$ $\equiv$ (while
      (HOL.Not $\circ$ is_term)
      ($\lambda$Some $cs$ $\Rightarrow$ fstep proc_table $cs$)
      (Some $cs$))"
  \end{lstlisting}

  \caption{Definition of an interpreter for Chloe}
  \label{fig:interpreter_def}
\end{figure}

In figure~\ref{fig:interpreter_def} we find such definition.
First we define the criteria on which a state is considered final.
A state will be considered final when its execution stack is empty or when it is \verb|None|.

The interpreter for our semantics works as follows: As long as a final state is not reached we execute \verb|fstep|.

Finally, we show a lemma that states that if a state is final, then it is the result of the interpretation.

\begin{lemma}[interp\_term]
$\newline$
$\mathtt{is\_term}\ \mathtt{(Some}\ cs\mathtt{)}\ \Longrightarrow\ \mathtt{interp}\ \mathtt{proc\_table}\ cs\ =\ \mathtt{Some}\ cs$
\label{lemma:interp_term}
\end{lemma}

In order to show this we need a lemma that unfolds the loop in the definition of our interpreter:

\begin{lemma}[interp\_unfold]
$\newline$
$\mathtt{interp}\ \mathtt{proc\_table}\ cs = ($
$\newline$
$\mathtt{if}\ \mathtt{is\_term}\ (\mathtt{Some}\ cs)\ \mathtt{then}\ \mathtt{Some}\ cs$
$\newline$
$\mathtt{else}\ \mathtt{do\{}\ cs \leftarrow\ \mathtt{fstep}\ \mathtt{proc\_table}\ cs\mathtt{;}\ \mathtt{interp}\ \mathtt{proc\_table}\ cs$
$\mathtt{\}})$
\label{lemma:interp_unfold}
\end{lemma}

\begin{proof}
The proof is solved automatically.
\end{proof}

With lemma~\ref{lemma:interp_unfold} the proof for lemma~\ref{lemma:interp_term} is solved automatically.

Finally, only valid programs can be executed. In figure~\ref{fig:execute_def} we can see the definition for the function that executes a program.
In order to execute a program we assert that it is valid with the previously defined \verb|valid_program| and then proceed to interpret the initial state of the program p.

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  definition execute :: "program $\Rightarrow$ state option" where
    "execute $p$ $\equiv$ do {
      assert (valid_program $p$);
      interp (proc_table_of $p$) (initial_state $p$)
    }"
  \end{lstlisting}

  \caption{Definition of an interpreter for Chloe}
  \label{fig:execute_def}
\end{figure}


\subsection{Correctness}\label{subsection:correctness}

Finally we must show our interpreter to be correct.
In figure~\ref{fig:execution_definitions} we have two definitions regarding execution.
The first one states that an execution of a state $cs$ \verb|yields| $cs'$ if we can take small steps from $cs$ to $cs'$ and $cs'$ is a final state.
Secondly, we define an execution of a state to terminate if there exists a state $cs'$ such that the execution of state $cs$ yields it.

\begin{figure}
  \begin{lstlisting}[frame=single, mathescape=true]
  definition "yields $\equiv$ $lambda\ cs\ cs'$. Some $cs$ $\rightarrow*$ $cs'$ $/wedge$ is_term cs'"

  definition "terminates $\equiv$ $lambda\ cs$. $\exists\ cs'$. yields $cs\ cs'$"
  \end{lstlisting}

  \caption{Definitions about program execution}
  \label{fig:execution_definitions}
\end{figure}

Before showing the correctness lemma for the correctness of the interpreter we must show that the small steps execution will preserve an erroneous \verb|None| state if it is reached by the path of steps taken.
Upon erroneous execution we will get stuck in a \verb|None| state.

\begin{lemma}[None\_star\_preserved]
$\newline$
$\mathtt{None}\ \rightarrow*\ z\ \longleftrightarrow\ z\ =\ \mathtt{None}$
\label{lemma:none_star_preserved}
\end{lemma}

\begin{proof}
The proof is by induction on the reflexive transitive closure (star).
The goals are solved automatically.
\end{proof}


Finally we show the correctness property for our interpreter.
Theorem~\ref{theorem:interp_correct} states that if the execution of $cs$ terminates, then that execution yields $cs'$ if and only if $cs'$ is the result we obtain from executing the program in the interpreter.
\begin{theorem}[interp\_correct]
$\newline$
$\mathtt{terminates}\ cs\ \Longrightarrow\ (\mathtt{yields}\ cs\ cs')\ \longleftrightarrow\ (cs'\ =\ \mathtt{interp}\ \mathtt{proc\_table}\ cs)$
\label{theorem:interp_correct}
\end{theorem}

\begin{proof}
The proof is done by assuming the premise and proving each direction of the equality separately.
\end{proof}
